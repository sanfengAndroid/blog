<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AntiOllvm演示教程</title>
    <url>/blog/2022/01/06/AntiOllvmUse/</url>
    <content><![CDATA[<h2 id="样本说明"><a href="#样本说明" class="headerlink" title="样本说明"></a>样本说明</h2><p>来自看雪论坛<a href="https://bbs.pediy.com/thread-270529.htm">对ollvm的算法进行逆向分析和还原</a></p>
<ul>
<li><a href="https://github.com/sanfengAndroid/AntiOllvm/blob/main/Arm64Test/kanxueOllvm/bin/libnative-lib.so">libnative-lib.so</a> 原版混淆的二进制文件</li>
<li><a href="https://github.com/sanfengAndroid/AntiOllvm/blob/main/Arm64Test/kanxueOllvm/bin/libnative-lib-anti.so">libnative-lib-anti.so</a> 去混淆后的二进制文件</li>
</ul>
<a id="more"></a>

<h3 id="去混淆函数"><a href="#去混淆函数" class="headerlink" title="去混淆函数"></a>去混淆函数</h3><ul>
<li>JNI_ONLoad 正常混淆，导出函数可以使用 <code>--select-functions</code> 选项设置名称。该函数主要调用 <code>RegisterNatives</code> 注册C函数</li>
<li>sub_12AE4 函数范围 0x12AE4-0x13AAC 存在很多小的混淆块，函数包含异常处理，还使用了向量指令，目前暂未添加该向量指令和异常处理，后续版本添加。</li>
<li>sub_1D1E8 函数范围 0x1D1E8-0x26300 函数体较大，存在很多小混淆块</li>
<li>sub_26300 函数范围 0x26300-0x26698 代码较少</li>
<li>sub_1B89C 函数范围 0x1B89C-0x1C918 函数，代码量中等</li>
</ul>
<h3 id="AntiOllvm-使用参数介绍"><a href="#AntiOllvm-使用参数介绍" class="headerlink" title="AntiOllvm 使用参数介绍"></a>AntiOllvm 使用参数介绍</h3><ul>
<li><code>--select-functions</code> 设置去混淆的函数名称，该函数必须在符号表中</li>
<li><code>--select-ranges</code> 设置去混淆的地址范围，最好一个范围一个函数，避免生成其它不必要函数，当解码函数是 Thumb 函数时，需要起始地址 + 1用来标识这是 <code>Thumb</code> 方法</li>
<li><code>-l</code> 输出优化后的 LLVM 位码，这可以用来检查错误</li>
<li><code>--config</code> 设置配置文件路径，用来读取默认配置</li>
<li>其它用法这里暂不介绍，请查看后续帮助文档</li>
</ul>
<h3 id="去混淆过程"><a href="#去混淆过程" class="headerlink" title="去混淆过程"></a>去混淆过程</h3><ul>
<li><p>使用命令  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">antiollvm.exe --config D:\retdec\install\share\retdec\decompiler-config.json .\libnative-lib.so --select-ranges 0x26300-0x26698,0x1b89c-0x1c918 --select-functions JNI_OnLoad</span><br><span class="line">antiollvm.exe --config D:\retdec\install\share\retdec\decompiler-config.json .\libnative-lib.so --select-ranges 0x1d1e8-26300</span><br></pre></td></tr></table></figure>
<p>第一条命令3个函数体较小，可以一次性去混淆。sub_1D1E8 函数较大单独运行避免占用内存太多</p>
</li>
<li><p>生成文件</p>
<ul>
<li>libnative-lib-anti.so 带有 <code>anti</code> 后缀是在原二进制文件的基础上替换掉混淆函数，多次运行不会覆盖它，只会在该文件基础上替换函数。</li>
<li>libnative-lib-compile.so 带有 <code>compile</code> 后缀是本次运行优化后的编译产物，该文件是可重定位文件，包含本次优化的所有相关变量和方法</li>
</ul>
</li>
</ul>
<h3 id="去混淆效果对比"><a href="#去混淆效果对比" class="headerlink" title="去混淆效果对比"></a>去混淆效果对比</h3><ul>
<li>JNI_ONLoad  </li>
</ul>
<p>去混淆之前<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/JNI_OnLoad_obf.png" alt="JNI_ONLoad_before">  </p>
<p>去混淆之后<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/JNI_OnLoad_antiobf.png" alt="JNI_ONLoad_after"></p>
<ul>
<li>sub_12AE4  </li>
</ul>
<p>去混淆之前<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/sub_12AE4_obf.png" alt="sub_12ae4_before">  </p>
<p>去混淆之后<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/sub_12AE4_antiobf.png" alt="sub_12ae4_after"></p>
<ul>
<li>sub_1D1E8  </li>
</ul>
<p>去混淆之前<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/sub_1D1E8_obf.png" alt="sub_1d1e8_before">  </p>
<p>去混淆之后<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/sub_1D1E8_antiobf.png" alt="sub_1d1e8_after"></p>
<ul>
<li>sub_26300  </li>
</ul>
<p>去混淆之前<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/sub_26300_obf.png" alt="sub_26300_before">  </p>
<p>去混淆之后<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/sub_26300_antiobf.png" alt="sub_26300_after"></p>
<ul>
<li>sub_1B89C  </li>
</ul>
<p>去混淆之前<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/sub_1B89C_obf.png" alt="sub_1b89c_before">  </p>
<p>去混淆之后<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/Arm64Test/kanxueOllvm/img/sub_1B89C_antiobf.png" alt="sub_1b89c_after"></p>
<h3 id="去混淆效果对比-1"><a href="#去混淆效果对比-1" class="headerlink" title="去混淆效果对比"></a>去混淆效果对比</h3><ul>
<li>JNI_ONLoad<video src="https://raw.githubusercontent.com/sanfengAndroid/AntiOllvm/main/Arm64Test/kanxueOllvm/video/kanxueollvm2.mp4" controls="controls" width="100%" height="auto"/></li>
</ul>
]]></content>
      <categories>
        <category>AntiOllvm</category>
      </categories>
      <tags>
        <tag>AntiOllvm</tag>
        <tag>Deobfuscate</tag>
      </tags>
  </entry>
  <entry>
    <title>AntiOllvm去除二进制代码Ollvm混淆并回编译</title>
    <url>/blog/2021/06/17/anti-ollvm-analysis/</url>
    <content><![CDATA[<h2 id="AntiOllvm"><a href="#AntiOllvm" class="headerlink" title="AntiOllvm"></a><a href="https://github.com/sanfengAndroid/AntiOllvm">AntiOllvm</a></h2><p>去除二进制文件 <code>Ollvm</code> 混淆，并生成新的可执行二进制文件</p>
<a id="more"></a>

<h2 id="其它方法介绍"><a href="#其它方法介绍" class="headerlink" title="其它方法介绍"></a>其它方法介绍</h2><ul>
<li>Ollvm 已经开源很久了，现在市面很多恶意软件都使用它，为了防止分析加壳加混淆基本是必备的。假如一个恶意软件使用某种算法加密了你的文件，并且采用了混淆，如果你要自己解密或者制作解密工具都离不开分析它的算法。而使用混淆后伪代码几乎不可查看，为此你要付出大量的时间和精力去分析。现在网上通用一点的方法有使用 <code>unicorn</code> 模拟执行，还有使用 <code>trace</code> 功能跟踪运行过的代码。</li>
<li>使用 <code>unicorn</code> 模拟执行<ul>
<li>虽然可以支持很多架构的运行，但是从汇编层构建出 <code>CFG</code> 还是比较吃力的</li>
<li>具体的分析都对应着直接的汇编指令，再加上多架构这样处理起来非常麻烦</li>
<li>还有修复跳转，补丁指令，在原函数中代码分散，甚至还需要修复指令的重定位</li>
</ul>
</li>
<li>使用 <code>trace</code> 跟踪<ul>
<li><code>trace</code> 分析相对较简单,但缺点是你需要在真机上运行</li>
<li>每次运行也不一定会覆盖所有路径</li>
<li>在还原算法或分析时看的是汇编指令，增加分析难度</li>
</ul>
</li>
</ul>
<h2 id="AntiOllvm-简介"><a href="#AntiOllvm-简介" class="headerlink" title="AntiOllvm 简介"></a>AntiOllvm 简介</h2><ul>
<li>采用将二进制代码还原为 <code>LLVM IR</code> 的方式，经过各种优化去除混淆后再编译回原文件</li>
<li>采用这种方案优点很多<ul>
<li>本身 <code>Ollvm</code> 就是在 <code>LLVM IR</code> 中转换代码然后编译，在还原回 <code>LLVM IR</code> 后能最大限度的还原特征</li>
<li>可以利用现有的 <code>LLVM</code> 中的优化，各种分析也可以查找部分现成的</li>
<li>统一了所有架构的分析，分析方法通用，重建 CFG 非常容易</li>
<li>分析过程更加直观，不接触汇编代码，更容易分析出混淆规则</li>
</ul>
</li>
</ul>
<h2 id="大概思路"><a href="#大概思路" class="headerlink" title="大概思路"></a>大概思路</h2><ul>
<li><code>AntiOllvm</code> 使用 <a href="https://github.com/avast/retdec">retdec</a> 将二进制文件还原为 <code>LLVM IR</code></li>
<li>使用 <code>LLVM</code> 中的内部优化，将 <code>IR</code> 码优化为较高可读性的代码，这期间部分指令替换以及不可达代码就已经优化掉了</li>
<li>定制 <code>Pass</code> 去除掉函数内部的 虚假控制流和平坦化</li>
<li>最后通过 <code>LLVM</code> 将代码重新编译回汇编并回填文件</li>
</ul>
<h2 id="开发进度"><a href="#开发进度" class="headerlink" title="开发进度"></a>开发进度</h2><table>
<thead>
<tr>
<th align="center">架构</th>
<th align="center">ELF</th>
<th align="center">COFF</th>
<th align="center">Mach-O</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Arm</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Arm64</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">X86</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">X86_64</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>等测试稳定会后陆续开放其它架构</li>
<li>IDA 插件的开发（需等所有架构开放后）</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ul>
<li>该项目是收费项目，<a href="https://github.com/sanfengAndroid/AntiOllvm">AntiOllvm</a>仓库只会存放说明文件和一些测试样本的源码和二进制文件</li>
<li>目前还未提供可购买版本，鉴于目前不够稳定，样本量较少，后续稳定后会推出正式可购买版本</li>
<li>欢迎大家提供样本（越复杂越好）到我的邮箱 <a href="https://mail.163.com/">beichenzhizuoshi@163.com</a>，也可在本仓库提交 <strong>issues</strong> 附带样本及说明，目前只接受 <code>Arm</code> 架构的 <code>ELF</code> 样本，发送样本时请在标题上注明 <strong>二进制架构及文件格式</strong> 例如 <strong>Arm-ELF 测试样本</strong>, 内容上注明被混淆的 <strong>函数名称或地址</strong>，和你自认为的 <strong>混淆难度等级（1-3）</strong>，我会在去混淆通过后回复你去混淆后的二进制文件</li>
</ul>
<h2 id="例子演示"><a href="#例子演示" class="headerlink" title="例子演示"></a>例子演示</h2><ul>
<li>见 <a href="https://github.com/sanfengAndroid/AntiOllvm">AntiOllvm</a>，在这个仓库会公布文档和一些测试的源码以及去混淆后的二进制文件</li>
<li>该样本是使用 <code>openssl</code> 加密库，开启混淆，注意测试与 <code>MD5</code> 算法有关方法 <code>MD5_Update</code>、<code>md5_block_data_order</code>，样本详细说明可以查看仓库 <a href="https://github.com/sanfengAndroid/AntiOllvm/blob/main/OpenSSLTest/doc/README_CN.md">OpenSSLTest</a></li>
<li>未混淆和去混淆后的运行对比<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/OpenSSLTest/doc/img/test-md5-video.gif" alt="gif"></li>
<li>混淆过后的 <code>MD5_Update</code> <code>CFG</code><br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/OpenSSLTest/doc/img/MD5_Update_cfg_obf.png" alt="MD5_Update Obf CFG"></li>
<li>混淆过后的 <code>md5_block_data_order</code> <code>CFG</code><br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/OpenSSLTest/doc/img/md5_block_data_order_cfg_obf.png" alt="md5_block_data_order Obf CFG"></li>
<li>未混淆 <code>MD5_Update</code> <code>CFG</code> 如下:<br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/OpenSSLTest/doc/img/MD5_Update_cfg_unobf.png" alt="MD5_Update CFG"></li>
<li>去混淆后 <code>MD5_Update</code> <code>CFG</code><br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/OpenSSLTest/doc/img/MD5_Update_cfg_antiobf.png" alt="MD5_Update AntiObf  CFG"></li>
<li>未混淆 <code>md5_block_data_order</code> <code>CFG</code><br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/OpenSSLTest/doc/img/md5_block_data_order_cfg_unobf.png" alt="md5_block_data_order CFG"></li>
<li>去混淆后 <code>md5_block_data_order</code> <code>CFG</code><br><img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/AntiOllvm@main/OpenSSLTest/doc/img/md5_block_data_order_cfg_antiobf.png" alt="CFG"></li>
</ul>
<h2 id="问题交流"><a href="#问题交流" class="headerlink" title="问题交流"></a>问题交流</h2><ul>
<li>请关注下方微信公众号后获取入群提示</li>
</ul>
]]></content>
      <categories>
        <category>AntiOllvm</category>
      </categories>
      <tags>
        <tag>AntiOllvm</tag>
        <tag>Deobfuscate</tag>
      </tags>
  </entry>
  <entry>
    <title>FakeXposed原理分析</title>
    <url>/blog/2021/02/20/fakexposed-principle-analyze/</url>
    <content><![CDATA[<h2 id="FakeXposed"><a href="#FakeXposed" class="headerlink" title="FakeXposed"></a><a href="https://github.com/sanfengAndroid/FakeXposed">FakeXposed</a></h2><p>一个通用多功能的 <code>Xposed</code> 隐藏器，采用 <code>Native</code> 与 <code>Java</code> 结合来做到双向屏蔽检测，提供高度自由化为每个应用配置不同属性。它不仅仅局限于屏蔽 <code>Xposed</code> 检测，还提供更多更加高级的功能，如 <code>maps</code> 文件自定义屏蔽各种检测、完整的文件重定向功能、访问权限控制、<code>JNI</code> 方法监控、动态符号查找屏蔽 <code>dlsym</code> 等等，还可以提供给其它模块在进程内动态添加或修改配置。开源地址 <a href="https://github.com/sanfengAndroid/FakeXposed">https://github.com/sanfengAndroid/FakeXposed</a></p>
<a id="more"></a>

<h2 id="原理简要介绍"><a href="#原理简要介绍" class="headerlink" title="原理简要介绍"></a>原理简要介绍</h2><ul>
<li><code>Native Hook</code> 使用我的另一开源项目 <a href="https://github.com/sanfengAndroid/fake-linker">fake-linker</a>，<code>Java Hook</code> 使用 <code>Xposed</code> 框架，大部分功能都是由 <code>Native Hook</code> 来完成，<code>Xposed</code> 不限于原版 <code>Xposed</code>、<code>EdXposed</code>、<code>VirtualXposed</code>等等</li>
<li>内部提供 <code>类</code>、<code>堆栈类</code>、<code>应用</code>、<code>环境变量</code>、<code>全局系统属性</code>、<code>Android Global属性</code>、<code>Runtime.exec拦截</code>、<code>文件访问/重定向等</code>、<code>符号拦截</code>，各种属性的隐藏和修改，下面我将简单介绍一些原理，代码都是基于 Android 最新源码主分支，旧分支一些变化不是太大自行分析即可</li>
</ul>
<h2 id="类-堆栈类隐藏"><a href="#类-堆栈类隐藏" class="headerlink" title="类/堆栈类隐藏"></a>类/堆栈类隐藏</h2><ul>
<li>Hook <code>Class.forName()</code>、<code>ClassLoader.loadClass()</code>、<code>Throwable.getStackTrace()</code> 方法，判断隐藏类加载则抛出异常或删除该元素。目前我在测试 <code>EdXposed</code> 中只有部分情况会走该回调，可能框架处理了有关部分</li>
</ul>
<h2 id="应用-组件隐藏"><a href="#应用-组件隐藏" class="headerlink" title="应用/组件隐藏"></a>应用/组件隐藏</h2><ul>
<li>使用动态代理 <code>PackageManager</code>、<code>ActivityManager</code>、<code>ActivityTaskManager</code>屏蔽常见会使用到获取其它应用属性的方法，如：<code>getInstalledPackages</code>、<code>getInstalledApplications</code>、<code>getRunningServices</code>、<code>getTasks</code>等等。应用进程本身就是通过 <code>Binder</code> 与 <code>system_server</code> 服务进程通信进程内只存在一个 <code>IBinger</code> 对象，因此非常适合使用动态代理，这里屏蔽掉几乎所有能够访问其它应用的方式，具体查看源码<a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/java/com/sanfengandroid/xp/hooks/HookSystemComponent.java">HookSystemComponent</a>。</li>
<li><code>PackageManager</code> 源码在 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ActivityThread.java;l=2185;bpv=0;bpt=0">ActivityThread.getPackageManager</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> IPackageManager sPackageManager;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> sPackageManager;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> IBinder b = ServiceManager.getService(<span class="string">&quot;package&quot;</span>);</span><br><span class="line">  sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">  <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因此只需要使用反射修改 <code>sPackageManager</code> 静态变量即可</li>
<li><code>ActivityManager</code> 源码 <code>AndroidO</code> 以上在 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ActivityManager.java;drc=master;l=4553?q=ActivityManager&ss=android/platform/superproject">ActivityManager.IActivityManagerSingleton</a>，<code>AndroidO</code> 以下在 <code>ActivityManagerNative.gDefault</code>，都是一个单例对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">  <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">          <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">          <span class="keyword">return</span> am;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
同样反射修改 <code>Singleton</code> 里面的对象即可</li>
<li><code>ActivityTaskManager</code> 是 <code>AndroidQ</code> 以上新增的一个服务，修改方法同 <code>ActivityManager</code></li>
</ul>
<h2 id="环境变量修改"><a href="#环境变量修改" class="headerlink" title="环境变量修改"></a>环境变量修改</h2><ul>
<li><p><code>Java</code> 调用 <code>System.getenv()</code>、<code>System.getenv(String)</code> 源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.util.<span class="function">Map&lt;String,String&gt; <span class="title">getenv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SecurityManager sm = getSecurityManager();</span><br><span class="line">  <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;getenv.*&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ProcessEnvironment.getenv();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getenv</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name == null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Libcore.os.getenv(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其最终调用两个函数 <code>Libcore.os.environ()</code>、<code>Libcore.os.getenv(String)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Libcore</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Libcore</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Os rawOs = <span class="keyword">new</span> Linux();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Os os = <span class="keyword">new</span> BlockGuardOs(rawOs);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> <span class="keyword">implements</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">  Linux() &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getenv</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">native</span> String[] environ();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同版本 <code>Libcore.os</code> 的实现对象类名不一样，但是区别很小，而 <code>native</code> 中访问到是 libc 导出变量 <code>environ</code>、导出函数 <code>getenv</code>，因此通过 <code>Native Hook</code> 拦截 <code>getenv</code> 函数即可拦截对应 Java <code>System.getenv(String)</code>调用，而 <code>System.getenv()</code> 调用是直接使用 <code>environ</code> 变量，因此暂时采用<code>Java Hook</code>替换该<code>Map</code>对象，通常情况下应用是很少使用到 <code>System.getenv</code> 非系统环境变量的，一些软件检测才会使用，因此后续可能会直接修改 <code>environ</code> 变量中的值</p>
</li>
</ul>
<h2 id="全局属性-SystemProperties-修改"><a href="#全局属性-SystemProperties-修改" class="headerlink" title="全局属性 SystemProperties 修改"></a>全局属性 SystemProperties 修改</h2><ul>
<li><p><code>Java</code> 反射使用 <code>SystemProperties.get</code> 系列方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@Nullable</span> String def)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TRACK_KEY_ACCESS) onKeyAccess(key);</span><br><span class="line">    <span class="keyword">return</span> native_get(key, def);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">native_get</span><span class="params">(String key, String def)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_os_SystemProperties.cpp">android_os_SystemProperties.cpp</a> 中的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadProperty</span><span class="params">(<span class="keyword">const</span> prop_info* prop, Functor&amp;&amp; functor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__BIONIC__)</span></span><br><span class="line">    <span class="keyword">auto</span> thunk = [](<span class="keyword">void</span>* cookie,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/*name*/</span>,</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">char</span>* value,</span><br><span class="line">                    <span class="keyword">uint32_t</span> <span class="comment">/*serial*/</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::forward&lt;Functor&gt;(*<span class="keyword">static_cast</span>&lt;Functor*&gt;(cookie))(value);</span><br><span class="line">    &#125;;</span><br><span class="line">    __system_property_read_callback(prop, thunk, &amp;functor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    LOG(FATAL) &lt;&lt; <span class="string">&quot;fast property access supported only on device&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadProperty</span><span class="params">(JNIEnv* env, jstring keyJ, Functor&amp;&amp; functor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">key</span><span class="params">(env, keyJ)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!key.c_str()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__BIONIC__)</span></span><br><span class="line">    <span class="keyword">const</span> prop_info* prop = __system_property_find(key.c_str());</span><br><span class="line">    <span class="keyword">if</span> (!prop) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ReadProperty(prop, <span class="built_in">std</span>::forward&lt;Functor&gt;(functor));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">std</span>::forward&lt;Functor&gt;(functor)(</span><br><span class="line">        android::base::GetProperty(key.c_str(), <span class="string">&quot;&quot;</span>).c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jstring <span class="title">SystemProperties_getSS</span><span class="params">(JNIEnv* env, jclass clazz, jstring keyJ,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring defJ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jstring ret = defJ;</span><br><span class="line">    ReadProperty(env, keyJ, [&amp;](<span class="keyword">const</span> <span class="keyword">char</span>* value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value[<span class="number">0</span>]) &#123;</span><br><span class="line">            ret = env-&gt;NewStringUTF(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">nullptr</span> &amp;&amp; !env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      ret = env-&gt;NewStringUTF(<span class="string">&quot;&quot;</span>);  <span class="comment">// Legacy behavior</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_os_SystemProperties</span><span class="params">(JNIEnv *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> JNINativeMethod method_table[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;native_get&quot;</span>,</span><br><span class="line">          <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_getSS &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_get_int&quot;</span>, <span class="string">&quot;(Ljava/lang/String;I)I&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_get_integral&lt;jint&gt; &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_get_long&quot;</span>, <span class="string">&quot;(Ljava/lang/String;J)J&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_get_integral&lt;jlong&gt; &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_get_boolean&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Z)Z&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_get_boolean &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_find&quot;</span>,</span><br><span class="line">          <span class="string">&quot;(Ljava/lang/String;)J&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_find &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_get&quot;</span>,</span><br><span class="line">          <span class="string">&quot;(J)Ljava/lang/String;&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_getH &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_get_int&quot;</span>, <span class="string">&quot;(JI)I&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_get_integralH&lt;jint&gt; &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_get_long&quot;</span>, <span class="string">&quot;(JJ)J&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_get_integralH&lt;jlong&gt; &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_get_boolean&quot;</span>, <span class="string">&quot;(JZ)Z&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_get_booleanH &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_set&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_set &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_add_change_callback&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_add_change_callback &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;native_report_sysprop_change&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span>*) SystemProperties_report_sysprop_change &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> RegisterMethodsOrDie(env, <span class="string">&quot;android/os/SystemProperties&quot;</span>,</span><br><span class="line">                                method_table, NELEM(method_table));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而它调用了 <code>libc.so</code> 中的 <code>__system_property_find</code>，<code>__system_property_read_callback</code>，在低版本中获取属性也使用到了 <code>__system_property_get</code> 方法，因此采用 <code>Native Hook</code> 以上这三个方法，这里也要注意不同版本在不同动态库中实现</p>
</li>
</ul>
<h2 id="Android-Global-属性修改"><a href="#Android-Global-属性修改" class="headerlink" title="Android Global 属性修改"></a>Android Global 属性修改</h2><ul>
<li>采用 Java Hook <code>Global.getString</code> 方法修改</li>
</ul>
<h2 id="Runtime-exec-拦截"><a href="#Runtime-exec-拦截" class="headerlink" title="Runtime.exec 拦截"></a>Runtime.exec 拦截</h2><ul>
<li><p>源码分析如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProcessBuilder(cmdarray)</span><br><span class="line">        .environment(envp)</span><br><span class="line">        .directory(dir)</span><br><span class="line">        .start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessBuilder</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Process <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessImpl.start(cmdarray,</span><br><span class="line">                                  environment,</span><br><span class="line">                                  dir,</span><br><span class="line">                                  redirects,</span><br><span class="line">                                  redirectErrorStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | IllegalArgumentException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Process <span class="title">start</span><span class="params">(String[] cmdarray,</span></span></span><br><span class="line"><span class="function"><span class="params">                       java.util.Map&lt;String,String&gt; environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                       String dir,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ProcessBuilder.Redirect[] redirects,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> redirectErrorStream)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> cmdarray != <span class="keyword">null</span> &amp;&amp; cmdarray.length &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Convert arguments to a contiguous block; it&#x27;s easier to do</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 复制环境变量</span></span><br><span class="line"></span><br><span class="line">      FileInputStream  f0 = <span class="keyword">null</span>;</span><br><span class="line">      FileOutputStream f1 = <span class="keyword">null</span>;</span><br><span class="line">      FileOutputStream f2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (redirects == <span class="keyword">null</span>) &#123;</span><br><span class="line">              std_fds = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重定向流</span></span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> UNIXProcess</span><br><span class="line">          (toCString(cmdarray[<span class="number">0</span>]),</span><br><span class="line">           argBlock, args.length,</span><br><span class="line">           envBlock, envc[<span class="number">0</span>],</span><br><span class="line">           toCString(dir),</span><br><span class="line">               std_fds,</span><br><span class="line">           redirectErrorStream);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// In theory, close() can throw IOException</span></span><br><span class="line">          <span class="comment">// (although it is rather unlikely to happen here)</span></span><br><span class="line">          <span class="keyword">try</span> &#123; <span class="keyword">if</span> (f0 != <span class="keyword">null</span>) f0.close(); &#125;</span><br><span class="line">          <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123; <span class="keyword">if</span> (f1 != <span class="keyword">null</span>) f1.close(); &#125;</span><br><span class="line">              <span class="keyword">finally</span> &#123; <span class="keyword">if</span> (f2 != <span class="keyword">null</span>) f2.close(); &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UNIXProcess</span> <span class="keyword">extends</span> <span class="title">Process</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">forkAndExec</span><span class="params">(<span class="keyword">byte</span>[] prog,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] argBlock, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] envBlock, <span class="keyword">int</span> envc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">byte</span>[] dir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span>[] fds,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> redirectErrorStream)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  UNIXProcess(<span class="keyword">final</span> <span class="keyword">byte</span>[] prog,</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">byte</span>[] argBlock, <span class="keyword">final</span> <span class="keyword">int</span> argc,</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">byte</span>[] envBlock, <span class="keyword">final</span> <span class="keyword">int</span> envc,</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">byte</span>[] dir,</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">int</span>[] fds,</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">boolean</span> redirectErrorStream)</span><br><span class="line">          <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">      pid = forkAndExec(prog,</span><br><span class="line">                        argBlock, argc,</span><br><span class="line">                        envBlock, envc,</span><br><span class="line">                        dir,</span><br><span class="line">                        fds,</span><br><span class="line">                        redirectErrorStream);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                  initStreams(fds);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">              &#125;&#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (PrivilegedActionException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> (IOException) ex.getException();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过跟踪 <code>Runtime.exec()</code> -&gt; <code>ProcessBuilder.start()</code> -&gt; <code>ProcessImpl.start()</code> -&gt; <code>new UNIXProcess()</code> -&gt; <code>UNIXProcess.forkAndExec()</code> 最终执行 <code>UNIXProcess.forkAndExec</code> 产生子进程，继续跟踪 <code>native</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">UNIXProcess_forkAndExec(JNIEnv *env,</span><br><span class="line">                                      jobject process,</span><br><span class="line">                                      jbyteArray prog,</span><br><span class="line">                                      jbyteArray argBlock, jint argc,</span><br><span class="line">                                      jbyteArray envBlock, jint envc,</span><br><span class="line">                                      jbyteArray dir,</span><br><span class="line">                                      jintArray std_fds,</span><br><span class="line">                                      jboolean redirectErrorStream)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 上面设置环境变量，重定向输入输出流</span></span><br><span class="line">    <span class="comment">// startChild关键函数启动子进程</span></span><br><span class="line">    resultPid = startChild(c);</span><br><span class="line">    assert(resultPid != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resultPid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        throwIOException(env, errno, START_CHILD_SYSTEM_CALL <span class="string">&quot; failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Catch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    restartableClose(fail[<span class="number">1</span>]); fail[<span class="number">1</span>] = <span class="number">-1</span>; <span class="comment">/* See: WhyCantJohnnyExec */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (readFully(fail[<span class="number">0</span>], &amp;errnum, <span class="keyword">sizeof</span>(errnum))) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">break</span>; <span class="comment">/* Exec succeeded */</span></span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">sizeof</span><span class="params">(errnum)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">waitpid</span><span class="params">(resultPid, <span class="literal">NULL</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        throwIOException(env, errnum, <span class="string">&quot;Exec failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Catch;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        throwIOException(env, errno, <span class="string">&quot;Read failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Catch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>] = (in [<span class="number">1</span>] != <span class="number">-1</span>) ? in [<span class="number">1</span>] : <span class="number">-1</span>;</span><br><span class="line">    fds[<span class="number">1</span>] = (out[<span class="number">0</span>] != <span class="number">-1</span>) ? out[<span class="number">0</span>] : <span class="number">-1</span>;</span><br><span class="line">    fds[<span class="number">2</span>] = (err[<span class="number">0</span>] != <span class="number">-1</span>) ? err[<span class="number">0</span>] : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">Finally:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> START_CHILD_USE_CLONE</span></span><br><span class="line">    <span class="built_in">free</span>(c-&gt;clone_stack);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Always clean up the child&#x27;s side of the pipes */</span></span><br><span class="line">    closeSafely(in [<span class="number">0</span>]);</span><br><span class="line">    closeSafely(out[<span class="number">1</span>]);</span><br><span class="line">    closeSafely(err[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Always clean up fail descriptors */</span></span><br><span class="line">    closeSafely(fail[<span class="number">0</span>]);</span><br><span class="line">    closeSafely(fail[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    releaseBytes(env, prog,     pprog);</span><br><span class="line">    releaseBytes(env, argBlock, pargBlock);</span><br><span class="line">    releaseBytes(env, envBlock, penvBlock);</span><br><span class="line">    releaseBytes(env, dir,      c-&gt;pdir);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(c-&gt;argv);</span><br><span class="line">    <span class="built_in">free</span>(c-&gt;envv);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fds != <span class="literal">NULL</span>)</span><br><span class="line">        (*env)-&gt;ReleaseIntArrayElements(env, std_fds, fds, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultPid;</span><br><span class="line"></span><br><span class="line">Catch:</span><br><span class="line">    <span class="comment">/* Clean up the parent&#x27;s side of the pipes in case of failure only */</span></span><br><span class="line">    closeSafely(in [<span class="number">1</span>]);</span><br><span class="line">    closeSafely(out[<span class="number">0</span>]);</span><br><span class="line">    closeSafely(err[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">goto</span> Finally;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最关键函数 <code>startChild</code> 继续跟踪</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pid_t</span></span><br><span class="line">startChild(ChildStuff *c) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> START_CHILD_USE_CLONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START_CHILD_CLONE_STACK_SIZE (64 * 1024)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * See clone(2).</span></span><br><span class="line"><span class="comment">    * Instead of worrying about which direction the stack grows, just</span></span><br><span class="line"><span class="comment">    * allocate twice as much and start the stack in the middle.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;clone_stack = <span class="built_in">malloc</span>(<span class="number">2</span> * START_CHILD_CLONE_STACK_SIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">/* errno will be set to ENOMEM */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> clone(childProcess,</span><br><span class="line">                c-&gt;clone_stack + START_CHILD_CLONE_STACK_SIZE,</span><br><span class="line">                CLONE_VFORK | CLONE_VM | SIGCHLD, c);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> START_CHILD_USE_VFORK</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * We separate the call to vfork into a separate function to make</span></span><br><span class="line"><span class="comment">    * very sure to keep stack of child from corrupting stack of parent,</span></span><br><span class="line"><span class="comment">    * as suggested by the scary gcc warning:</span></span><br><span class="line"><span class="comment">    *  warning: variable &#x27;foo&#x27; might be clobbered by &#x27;longjmp&#x27; or &#x27;vfork&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">pid_t</span> resultPid = vfork();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * From Solaris fork(2): In Solaris 10, a call to fork() is</span></span><br><span class="line"><span class="comment">    * identical to a call to fork1(); only the calling thread is</span></span><br><span class="line"><span class="comment">    * replicated in the child process. This is the POSIX-specified</span></span><br><span class="line"><span class="comment">    * behavior for fork().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">pid_t</span> resultPid = fork();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (resultPid == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 子进程处理对应命令</span></span><br><span class="line">        childProcess(c);</span><br><span class="line">    assert(resultPid != <span class="number">0</span>);  <span class="comment">/* childProcess never returns */</span></span><br><span class="line">    <span class="keyword">return</span> resultPid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! START_CHILD_USE_CLONE */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>clone</code>、<code>vfork</code>、<code>fork</code> 函数产生子进程然后调用 <code>childProcess(c)</code> 处理命令，这里使用哪一个函数产生子进程不是重点，我们关心的是子进程如何执行命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">childProcess(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> ChildStuff* p = (<span class="keyword">const</span> ChildStuff*) arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Close the parent sides of the pipes.</span></span><br><span class="line"><span class="comment">      Closing pipe fds here is redundant, since closeDescriptors()</span></span><br><span class="line"><span class="comment">      would do it anyways, but a little paranoia is a good thing. */</span></span><br><span class="line">    <span class="keyword">if</span> ((closeSafely(p-&gt;in[<span class="number">1</span>])   == <span class="number">-1</span>) ||</span><br><span class="line">        (closeSafely(p-&gt;out[<span class="number">0</span>])  == <span class="number">-1</span>) ||</span><br><span class="line">        (closeSafely(p-&gt;err[<span class="number">0</span>])  == <span class="number">-1</span>) ||</span><br><span class="line">        (closeSafely(p-&gt;fail[<span class="number">0</span>]) == <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">goto</span> WhyCantJohnnyExec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Give the child sides of the pipes the right fileno&#x27;s. */</span></span><br><span class="line">    <span class="comment">/* Note: it is possible for in[0] == 0 */</span></span><br><span class="line">    <span class="keyword">if</span> ((moveDescriptor(p-&gt;in[<span class="number">0</span>] != <span class="number">-1</span> ?  p-&gt;in[<span class="number">0</span>] : p-&gt;fds[<span class="number">0</span>],</span><br><span class="line">                        STDIN_FILENO) == <span class="number">-1</span>) ||</span><br><span class="line">        (moveDescriptor(p-&gt;out[<span class="number">1</span>]!= <span class="number">-1</span> ? p-&gt;out[<span class="number">1</span>] : p-&gt;fds[<span class="number">1</span>],</span><br><span class="line">                        STDOUT_FILENO) == <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">goto</span> WhyCantJohnnyExec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;redirectErrorStream) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((closeSafely(p-&gt;err[<span class="number">1</span>]) == <span class="number">-1</span>) ||</span><br><span class="line">            (restartableDup2(STDOUT_FILENO, STDERR_FILENO) == <span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">goto</span> WhyCantJohnnyExec;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (moveDescriptor(p-&gt;err[<span class="number">1</span>] != <span class="number">-1</span> ? p-&gt;err[<span class="number">1</span>] : p-&gt;fds[<span class="number">2</span>],</span><br><span class="line">                          STDERR_FILENO) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">goto</span> WhyCantJohnnyExec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (moveDescriptor(p-&gt;fail[<span class="number">1</span>], FAIL_FILENO) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> WhyCantJohnnyExec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* close everything */</span></span><br><span class="line">    <span class="keyword">if</span> (closeDescriptors() == <span class="number">0</span>) &#123; <span class="comment">/* failed,  close the old way */</span></span><br><span class="line">        <span class="keyword">int</span> max_fd = (<span class="keyword">int</span>)sysconf(_SC_OPEN_MAX);</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">for</span> (fd = FAIL_FILENO + <span class="number">1</span>; fd &lt; max_fd; fd++)</span><br><span class="line">            <span class="keyword">if</span> (restartableClose(fd) == <span class="number">-1</span> &amp;&amp; errno != EBADF)</span><br><span class="line">                <span class="keyword">goto</span> WhyCantJohnnyExec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* change to the new working directory */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;pdir != <span class="literal">NULL</span> &amp;&amp; chdir(p-&gt;pdir) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> WhyCantJohnnyExec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fcntl(FAIL_FILENO, F_SETFD, FD_CLOEXEC) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> WhyCantJohnnyExec;</span><br><span class="line">    <span class="comment">// 最终调用 JDK_execvpe 执行命令</span></span><br><span class="line">    JDK_execvpe(p-&gt;argv[<span class="number">0</span>], p-&gt;argv, p-&gt;envv);</span><br><span class="line"></span><br><span class="line">WhyCantJohnnyExec:</span><br><span class="line">    <span class="comment">/* We used to go to an awful lot of trouble to predict whether the</span></span><br><span class="line"><span class="comment">    * child would fail, but there is no reliable way to predict the</span></span><br><span class="line"><span class="comment">    * success of an operation without *trying* it, and there&#x27;s no way</span></span><br><span class="line"><span class="comment">    * to try a chdir or exec in the parent.  Instead, all we need is a</span></span><br><span class="line"><span class="comment">    * way to communicate any failure back to the parent.  Easy; we just</span></span><br><span class="line"><span class="comment">    * send the errno back to the parent over a pipe in case of failure.</span></span><br><span class="line"><span class="comment">    * The tricky thing is, how do we communicate the *success* of exec?</span></span><br><span class="line"><span class="comment">    * We use FD_CLOEXEC together with the fact that a read() on a pipe</span></span><br><span class="line"><span class="comment">    * yields EOF when the write ends (we have two of them!) are closed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> errnum = errno;</span><br><span class="line">        restartableWrite(FAIL_FILENO, &amp;errnum, <span class="keyword">sizeof</span>(errnum));</span><br><span class="line">    &#125;</span><br><span class="line">    restartableClose(FAIL_FILENO);</span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* Suppress warning &quot;no return value from function&quot; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">JDK_execvpe(<span class="keyword">const</span> <span class="keyword">char</span> *file,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *argv[],</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (envp == <span class="literal">NULL</span> || (<span class="keyword">char</span> **) envp == environ) &#123;</span><br><span class="line">        execvp(file, (<span class="keyword">char</span> **) argv);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*file == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        errno = ENOENT;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(file, <span class="string">&#x27;/&#x27;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        execve_with_shell_fallback(file, argv, envp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We must search PATH (parent&#x27;s, not child&#x27;s) */</span></span><br><span class="line">        <span class="keyword">char</span> expanded_file[PATH_MAX];</span><br><span class="line">        <span class="keyword">int</span> filelen = <span class="built_in">strlen</span>(file);</span><br><span class="line">        <span class="keyword">int</span> sticky_errno = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> * dirs;</span><br><span class="line">        <span class="keyword">for</span> (dirs = parentPathv; *dirs; dirs++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> * dir = *dirs;</span><br><span class="line">            <span class="keyword">int</span> dirlen = <span class="built_in">strlen</span>(dir);</span><br><span class="line">            <span class="keyword">if</span> (filelen + dirlen + <span class="number">1</span> &gt;= PATH_MAX) &#123;</span><br><span class="line">                errno = ENAMETOOLONG;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(expanded_file, dir, dirlen);</span><br><span class="line">            <span class="built_in">memcpy</span>(expanded_file + dirlen, file, filelen);</span><br><span class="line">            expanded_file[dirlen + filelen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            execve_with_shell_fallback(expanded_file, argv, envp);</span><br><span class="line">            <span class="comment">/* There are 3 responses to various classes of errno:</span></span><br><span class="line"><span class="comment">            * return immediately, continue (especially for ENOENT),</span></span><br><span class="line"><span class="comment">            * or continue with &quot;sticky&quot; errno.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * From exec(3):</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * If permission is denied for a file (the attempted</span></span><br><span class="line"><span class="comment">            * execve returned EACCES), these functions will continue</span></span><br><span class="line"><span class="comment">            * searching the rest of the search path.  If no other</span></span><br><span class="line"><span class="comment">            * file is found, however, they will return with the</span></span><br><span class="line"><span class="comment">            * global variable errno set to EACCES.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">switch</span> (errno) &#123;</span><br><span class="line">            <span class="keyword">case</span> EACCES:</span><br><span class="line">                sticky_errno = errno;</span><br><span class="line">                <span class="comment">/* FALLTHRU */</span></span><br><span class="line">            <span class="keyword">case</span> ENOENT:</span><br><span class="line">            <span class="keyword">case</span> ENOTDIR:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ELOOP</span></span><br><span class="line">            <span class="keyword">case</span> ELOOP:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ESTALE</span></span><br><span class="line">            <span class="keyword">case</span> ESTALE:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENODEV</span></span><br><span class="line">            <span class="keyword">case</span> ENODEV:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ETIMEDOUT</span></span><br><span class="line">            <span class="keyword">case</span> ETIMEDOUT:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* Try other directories in PATH */</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sticky_errno != <span class="number">0</span>)</span><br><span class="line">            errno = sticky_errno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">execve_with_shell_fallback(<span class="keyword">const</span> <span class="keyword">char</span> *file,</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">char</span> *argv[],</span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> START_CHILD_USE_CLONE || START_CHILD_USE_VFORK</span></span><br><span class="line">    <span class="comment">/* shared address space; be very careful. */</span></span><br><span class="line">    execve(file, (<span class="keyword">char</span> **) argv, (<span class="keyword">char</span> **) envp);</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOEXEC)</span><br><span class="line">        execve_as_traditional_shell_script(file, argv, envp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* unshared address space; we can mutate environ. */</span></span><br><span class="line">    environ = (<span class="keyword">char</span> **) envp;</span><br><span class="line">    execvp(file, (<span class="keyword">char</span> **) argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面分析，最终调用 <code>JDK_execvpe</code> -&gt; <code>execve_with_shell_fallback</code> -&gt; <code>execve/execvp</code> 执行命令，实际测试执行 <code>Runtime.exec</code> 最终执行到 <code>execvp</code> 中。由于 <code>fork</code> 子进程后会继承父进程的环境，因此也可通过 <code>Native Hook</code> 来拦截该函数，但是实际测试中如果拦截 <code>execvp</code> 会导致子进程一直无法结束，从而导致卡住，这里原因暂时不明，有知道的可以留言告诉我。因此还是老实采用 <code>Java Hook</code> 更底层方法 <code>java.lang.UNIXProcess</code> 构造方法，对于低版本 Hook <code>java.lang.ProcessManager.exec</code> 方法。基于此提供命令，参数替换，以及固定输入、输出、错误流。具体源码查看 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/java/com/sanfengandroid/xp/hooks/HookRuntime.java">HookRuntime</a></p>
</li>
</ul>
<h2 id="文件重定向-访问控制（核心）"><a href="#文件重定向-访问控制（核心）" class="headerlink" title="文件重定向/访问控制（核心）"></a>文件重定向/访问控制（核心）</h2><ul>
<li>文件重定向/黑名单：<code>Native Hook</code> 与 IO 有关的方法，由于我们使用的 <code>PLT Hook</code> 因此要尽可能的包含全部函数<ul>
<li>如 <code>openat</code>、<code>__openat</code>、<code>open</code>、<code>fopen</code> 等 <code>libc</code> 函数，<code>Java</code> 中的 <code>File</code> 使用调用到 <code>Libcore.os</code> 中，这与上面分析环境变量类似，因此只需要 <code>Hook</code> libc 中的 IO 函数即可，查看代码<a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_io.cpp">hook_io</a>。</li>
<li><code>syscall</code> 函数，自己实现 <code>软中断系统调用</code> 的无法拦截，其 <code>inline Hook</code> 框架也无法拦截，只能通过修改内核或动态查找 <code>软中断系统调用</code> 然后再 Hook，这种极个别情况忽略，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_syscall.cpp">hook_syscall</a></li>
<li><code>exec</code> 簇执行函数，它会传入可执行文件路径，也需要重定向，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_exec.cpp">hook_exec</a></li>
<li>与时间相关函数 <code>utimes</code>、<code>utime</code>、<code>lutimes</code>，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_time.cpp">hook_time</a></li>
<li>与文件访问路径相关函数 <code>chdir</code>、<code>linkat</code>等，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_unistd.cpp">hook_unistd</a></li>
<li>与文件状态相关函数 <code>fchmodat</code>、<code>fstatat</code>、<code>stat</code>等，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_stat.cpp">hook_stat</a></li>
<li><code>maps</code> 文件过滤，基于文件重定向，当要访问 <code>maps</code> 文件时将修改掉需要过滤的数据然后将它重定向到缓存路径，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/io_redirect.cpp">io_redirect</a></li>
<li>动态加载函数 <code>dlopen</code>、<code>android_dlopen_ext</code>，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_dlfcn.cpp">hook_dlfcn</a></li>
</ul>
</li>
<li>文件权限控制<ul>
<li><code>stat</code> <code>fstatat</code>、<code>access</code> 等函数，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_stat.cpp">hook_stat</a></li>
</ul>
</li>
</ul>
<h2 id="符号隐藏"><a href="#符号隐藏" class="headerlink" title="符号隐藏"></a>符号隐藏</h2><ul>
<li>Native Hook <code>dlsym</code> 函数，屏蔽一些符号查找和重定向 <code>libc</code> 库中的函数到 <code>Hook 模块</code> 中，查看代码 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_dlfcn.cpp">hook_dlfcn</a></li>
</ul>
<h2 id="系统共享库查找"><a href="#系统共享库查找" class="headerlink" title="系统共享库查找"></a>系统共享库查找</h2><ol>
<li>上面 Hook 的 <code>native</code> 方法都是 <code>libc</code> 中的导出方法，要让 <code>Native Hook</code> 生效我们则需要重定位那些已经加载过的动态库，其中系统中最主要使用的 <code>Libcore</code> 库，我们通过查找 <code>Android.bp</code>(旧版本 <code>Android.mk</code>)来查找共享库名称，如果没找到名称则目录一级一级的向上继续查找，下面与最新版 <code>Libcore</code> 为例，其它版本类似</li>
</ol>
<ul>
<li><p>如上面频繁使用的 <code>libcore_io_Linux.cpp</code> 为例，源码路径在 <code>libcore/luni/src/main/native/libcore_io_Linux.cpp</code>，它所属的编译模块 <code>Android.bp(libcore/luni/src/main/native/Android.bp)</code>，有关配置如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">package &#123;</span><br><span class="line">    <span class="comment">// http://go/android-license-faq</span></span><br><span class="line">    <span class="comment">// A large-scale-change added &#x27;default_applicable_licenses&#x27; to import</span></span><br><span class="line">    <span class="comment">// the below license kinds from &quot;libcore_luni_license&quot;:</span></span><br><span class="line">    <span class="comment">//   SPDX-license-identifier-Apache-2.0</span></span><br><span class="line">    default_applicable_licenses: [<span class="string">&quot;libcore_luni_license&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filegroup &#123;</span><br><span class="line">    name: <span class="string">&quot;luni_native_srcs&quot;</span>,</span><br><span class="line">    visibility: [</span><br><span class="line">        <span class="string">&quot;//libcore&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">&quot;ExecStrings.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;IcuUtilities.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;JniConstants.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;JniException.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NetworkUtilities.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Register.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ZipUtilities.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;android_system_OsConstants.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cbigint.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;java_lang_StringToReal.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;java_lang_invoke_MethodHandle.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;java_lang_invoke_VarHandle.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libcore_math_NativeBN.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libcore_icu_ICU.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libcore_io_AsynchronousCloseMonitor.cpp&quot;</span>,</span><br><span class="line">        <span class="comment">// 这里包含我们需要拦截的源代码</span></span><br><span class="line">        <span class="string">&quot;libcore_io_Linux.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libcore_io_Memory.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libcore_util_NativeAllocationRegistry.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;org_apache_harmony_xml_ExpatParser.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sun_misc_Unsafe.cpp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;valueOf.cpp&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filegroup &#123;</span><br><span class="line">    name: <span class="string">&quot;libandroidio_srcs&quot;</span>,</span><br><span class="line">    visibility: [</span><br><span class="line">        <span class="string">&quot;//libcore&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">&quot;AsynchronousCloseMonitor.cpp&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里没有找到模块名称，则继续向上级目录查找编译脚本，上层找到 <code>libcore/luni/Android.bp</code>，配置如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">package &#123;</span><br><span class="line">  default_applicable_licenses: [<span class="string">&quot;libcore_luni_license&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Added automatically by a large-scale-change</span></span><br><span class="line"><span class="comment">// http://go/android-license-faq</span></span><br><span class="line">license &#123;</span><br><span class="line">    name: <span class="string">&quot;libcore_luni_license&quot;</span>,</span><br><span class="line">    visibility: [<span class="string">&quot;:__subpackages__&quot;</span>],</span><br><span class="line">    license_kinds: [</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-Apache-2.0&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    license_text: [</span><br><span class="line">        <span class="string">&quot;license.html&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是没找到名称继续往上查找 <code>libcore/Android.bp</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">license &#123;</span><br><span class="line">    name: <span class="string">&quot;libcore_license&quot;</span>,</span><br><span class="line">    visibility: [<span class="string">&quot;:__subpackages__&quot;</span>],</span><br><span class="line">    license_kinds: [</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-Apache-2.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-BSD&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-GPL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-GPL-2.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-LGPL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-MIT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-OpenSSL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-Unicode-DFS&quot;</span>,</span><br><span class="line">        <span class="string">&quot;SPDX-license-identifier-W3C&quot;</span>,</span><br><span class="line">        <span class="string">&quot;legacy_unencumbered&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    license_text: [</span><br><span class="line">        <span class="string">&quot;LICENSE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NOTICE&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build = [</span><br><span class="line">    <span class="string">&quot;JavaLibrary.bp&quot;</span>,</span><br><span class="line">    <span class="comment">// 这里有两个编译脚本</span></span><br><span class="line">    <span class="string">&quot;NativeCode.bp&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">genrule &#123;</span><br><span class="line">    name: <span class="string">&quot;notices-for-framework-stubs-gen&quot;</span>,</span><br><span class="line">    tool_files: [</span><br><span class="line">        <span class="string">&quot;NOTICE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ojluni/NOTICE&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    cmd: <span class="string">&quot;cp -f $(location NOTICE) $(genDir)/NOTICES/libcore-NOTICE &amp;&amp; cp -f $(location ojluni/NOTICE) $(genDir)/NOTICES/ojluni-NOTICE&quot;</span>,</span><br><span class="line">    out: [</span><br><span class="line">        <span class="string">&quot;NOTICES/libcore-NOTICE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NOTICES/ojluni-NOTICE&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java_library &#123;</span><br><span class="line">    name: <span class="string">&quot;art-notices-for-framework-stubs-jar&quot;</span>,</span><br><span class="line">    visibility: [</span><br><span class="line">        <span class="string">&quot;//art/build/sdk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;//frameworks/base&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    java_resources: [</span><br><span class="line">        <span class="string">&quot;:notices-for-framework-stubs-gen&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    sdk_version: <span class="string">&quot;core_current&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 <code>NativeCode.bp</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cc_library_shared &#123;</span><br><span class="line">    name: <span class="string">&quot;libjavacore&quot;</span>,</span><br><span class="line">    visibility: [</span><br><span class="line">        <span class="string">&quot;//art/build/apex&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    apex_available: [</span><br><span class="line">        <span class="string">&quot;com.android.art&quot;</span>,</span><br><span class="line">        <span class="string">&quot;com.android.art.debug&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    defaults: [</span><br><span class="line">        <span class="string">&quot;core_native_default_flags&quot;</span>,</span><br><span class="line">        <span class="string">&quot;core_native_default_libs&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">&quot;:luni_native_srcs&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">&quot;libandroidio&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libbase&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libcrypto&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libicu&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libexpat&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libnativehelper&quot;</span>,</span><br><span class="line">        <span class="string">&quot;libz&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    static_libs: [</span><br><span class="line">        <span class="string">&quot;libziparchive&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终找到该名称为 <code>libjavacore.so</code></p>
</li>
</ul>
<ol start="2">
<li><p>根据代码位置猜测，或者直接在 <code>maps</code> 文件里面查找哪些已经加载的可疑的库，目前查找到系统有关的库包含如下几个</p>
<ul>
<li><code>libjavacore.so</code> 与文件重定向、文件状态、exec 执行有关</li>
<li><code>libnativehelper.so</code> 与动态加载有关</li>
<li><code>libnativeloader.so</code> Android 7 以上动态加载有关</li>
<li><code>libart.so</code> 与文件重定向、动态加载有关</li>
<li><code>libopenjdk.so</code> 与文件重定向、文件状态有关</li>
<li><code>libopenjdkjvm.so</code> 与文件访问有关</li>
<li><code>libandroid_runtime.so</code> 与文件访问有关</li>
<li><code>libcutils.so</code> 与 SystemProperties 访问有关</li>
</ul>
</li>
<li><p>如果有遗漏的库可以调用 <code>NativeHook.relinkLibrary()</code> 重新重定位该库</p>
</li>
</ol>
<h2 id="其它模块调用"><a href="#其它模块调用" class="headerlink" title="其它模块调用"></a>其它模块调用</h2><p>查看 <a href="https://github.com/sanfengAndroid/FakeXposed">FakeXposed</a> 说明文档</p>
<h2 id="软件使用截图"><a href="#软件使用截图" class="headerlink" title="软件使用截图"></a>软件使用截图</h2><ul>
<li>软件状态 <img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/FakeXposed@main/capture/cn/home.png" alt="home"></li>
<li>应用配置，长按开启/关闭 <img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/FakeXposed@main/capture/cn/package_configuration.png" alt="package_configuration"></li>
<li>对应功能配置 <img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/FakeXposed@main/capture/cn/package_hidden.png" alt="package_hidden"> <img data-src="https://cdn.jsdelivr.net/gh/sanfengAndroid/FakeXposed@main/capture/cn/dlsym_hidden.png" alt="dlsym_hidden"></li>
</ul>
<h3 id="注意：Native-Hook-可能会存在兼容性问题，在-Hook-系统进程时请做好备份"><a href="#注意：Native-Hook-可能会存在兼容性问题，在-Hook-系统进程时请做好备份" class="headerlink" title="注意：Native Hook 可能会存在兼容性问题，在 Hook 系统进程时请做好备份"></a><strong>注意：Native Hook 可能会存在兼容性问题，在 Hook 系统进程时请做好备份</strong></h3><h3 id="软件没有经过大量测试，有问题的可以到-github-反馈、文章留言、公众号留言均可"><a href="#软件没有经过大量测试，有问题的可以到-github-反馈、文章留言、公众号留言均可" class="headerlink" title="软件没有经过大量测试，有问题的可以到 github 反馈、文章留言、公众号留言均可"></a><strong>软件没有经过大量测试，有问题的可以到 github 反馈、文章留言、公众号留言均可</strong></h3>]]></content>
      <categories>
        <category>Android Hook</category>
      </categories>
      <tags>
        <tag>Android Hook</tag>
        <tag>PLT Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 动态修改Linker实现LD_PRELOAD全局库PLT Hook</title>
    <url>/blog/2021/01/10/modify-linker-to-implement-plt-hook/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道linux系统中存在 <code>LD_PRELOAD</code> 环境变量更改库的链接顺序，影响库的导入函数重定位，而Android使用linux是内核也包含 <code>LD_PRELOAD</code>环境变量，具体使用路径在 <a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=352">linker_main.cpp</a> 中(本文分析源码如未特别提及则都基于最新主分支)。在执行<code>linker</code>初始化时访问了该环境变量，后续优先加载将其作为全局库从而影响之后该进程加载的所有库的符号链接，因此后续我们将围绕该环境变量展开</p>
<a id="more"></a>

<h2 id="环境变量的初始化、获取、修改"><a href="#环境变量的初始化、获取、修改" class="headerlink" title="环境变量的初始化、获取、修改"></a>环境变量的初始化、获取、修改</h2><p>环境变量的获取：获取环境变量使用libc中的<code>getenv</code>方法，而其中使用的全局变量声明为<code>extern &quot;C&quot; char** environ;</code>，该导出符号在<code>libc.so</code>库中，因此我们也可以通过<code>dlsym(libchandler, &quot;environ&quot;)</code>来遍历当前进程的所有环境变量。</p>
<p>环境变量的修改：调用libc中的<code>putenv</code>，如果不存在则添加，存在则会替换为新值</p>
<p>环境变量的初始化：在<code>linker_main.cpp</code>文件中的<a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=318">linker_main</a>方法中有调用<code>__libc_init_AT_SECURE(args.envp)</code>，该函数具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __libc_init_AT_SECURE(<span class="keyword">char</span>** env) &#123;</span><br><span class="line">  <span class="comment">// Check that the kernel provided a value for AT_SECURE.</span></span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> is_AT_SECURE = getauxval(AT_SECURE);</span><br><span class="line">  <span class="keyword">if</span> (errno != <span class="number">0</span>) __early_abort(__LINE__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Always ensure that STDIN/STDOUT/STDERR exist. This prevents file</span></span><br><span class="line">  <span class="comment">// descriptor confusion bugs where a parent process closes</span></span><br><span class="line">  <span class="comment">// STD*, the exec()d process calls open() for an unrelated reason,</span></span><br><span class="line">  <span class="comment">// the newly created file descriptor is assigned</span></span><br><span class="line">  <span class="comment">// 0&lt;=FD&lt;=2, and unrelated code attempts to read / write to the STD*</span></span><br><span class="line">  <span class="comment">// FDs.</span></span><br><span class="line">  <span class="comment">// In particular, this can be a security bug for setuid/setgid programs.</span></span><br><span class="line">  <span class="comment">// For example:</span></span><br><span class="line">  <span class="comment">// https://www.freebsd.org/security/advisories/FreeBSD-SA-02:23.stdio.asc</span></span><br><span class="line">  <span class="comment">// However, for robustness reasons, we don&#x27;t limit these protections to</span></span><br><span class="line">  <span class="comment">// just security critical executables.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Init is excluded from these protections unless AT_SECURE is set, as</span></span><br><span class="line">  <span class="comment">// /dev/null and/or /sys/fs/selinux/null will not be available at</span></span><br><span class="line">  <span class="comment">// early boot.</span></span><br><span class="line">  <span class="keyword">if</span> ((getpid() != <span class="number">1</span>) || is_AT_SECURE) &#123;</span><br><span class="line">    __nullify_closed_stdio();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_AT_SECURE) &#123;</span><br><span class="line">    __sanitize_environment_variables(env);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now the environment has been sanitized, make it available.</span></span><br><span class="line">  environ = __libc_shared_globals()-&gt;init_environ = env;</span><br><span class="line"></span><br><span class="line">  __initialize_personality();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数初始化了<code>environ</code>全局变量，但是该初始化很明显是在<code>linker</code>可执行文件内初始化的跟我们上面所说的在<code>libc.so</code>中不同，且这个时候还根本没有装载<code>libc.so</code>这个库，这就要看<code>__libc_shared_globals()</code>是如何返回的，查找申明结果查找到两个，一个是在<a href="https://cs.android.com/android/platform/superproject/+/master:bionic/libc/bionic/libc_init_dynamic.cpp;l=159;drc=master;bpv=1;bpt=1">libc_init_dynamic.cpp</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> libc_shared_globals* __loader_shared_globals();</span><br><span class="line">__LIBC_HIDDEN__ libc_shared_globals* __libc_shared_globals() &#123;</span><br><span class="line">  <span class="keyword">return</span> __loader_shared_globals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个是在<a href="https://cs.android.com/android/platform/superproject/+/master:bionic/libc/bionic/libc_init_static.cpp;drc=master;bpv=1;bpt=1;l=329">libc_init_static.cpp</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__LIBC_HIDDEN__ libc_shared_globals* __libc_shared_globals() &#123;</span><br><span class="line">  <span class="keyword">static</span> libc_shared_globals globals;</span><br><span class="line">  <span class="keyword">return</span> &amp;globals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出第一个是调用一个外部函数，而第二个是直接返回静态变量，这是因为<code>libc</code>编译成静态库<code>libc.a</code>使用<code>libc_init_static</code>，编译成动态库<code>libc.so</code>使用<code>libc_init_dynamic</code>，因此<code>libc.so</code>中并不存在<code>__libc_shared_globals</code>方法的实现，使用IDA分析<code>libc.so</code>也可发现<code>__libc_shared_globals</code>是导入函数。那么谁实现了该函数呢，正是 <code>linker</code> 实现了该函数并导出该符号，使用IDA分析 <code>linker</code> 可发现该导出函数。因为 <code>linker</code> 模块本身要使用一些<code>libc</code>函数，而它本身又作为动态链接器无法依赖其它库，因此自身静态链接了一份<code>libc</code>，所以上面使用<code>getenv</code>实际上是访问了<code>linker</code>中局部静态变量<code>globals</code>数据</p>
<p>环境变量的值设置：上述初始化环境变量使用<code>__libc_init_AT_SECURE(args.envp)</code>，<code>args.envp</code>正是该环境变量，函数调用向上回溯<code>__linker_init_post_relocation()</code>，继续向上回溯<a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker_main.cpp;l=661;bpv=0;bpt=1">__linker_init()</a>，该函数是 <code>linker</code> 的入口函数，其有关环境变量设置代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> ElfW(Addr) __linker_init(<span class="keyword">void</span>* raw_args) &#123;</span><br><span class="line">  <span class="comment">// Initialize TLS early so system calls and errno work.</span></span><br><span class="line">  <span class="comment">// args中包含后续使用的环境变量</span></span><br><span class="line">  <span class="function">KernelArgumentBlock <span class="title">args</span><span class="params">(raw_args)</span></span>;</span><br><span class="line">  bionic_tcb temp_tcb __attribute__((uninitialized));</span><br><span class="line">  linker_memclr(&amp;temp_tcb, <span class="keyword">sizeof</span>(temp_tcb));</span><br><span class="line">  __libc_init_main_thread_early(args, &amp;temp_tcb);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cs.android.com/android/platform/superproject/+/master:bionic/libc/private/KernelArgumentBlock.h;drc=master;bpv=0;bpt=1;l=30">KernelArgumentBlock</a>源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;link.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;platform/bionic/macros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// When the kernel starts the dynamic linker, it passes a pointer to a block</span></span><br><span class="line"><span class="comment">// of memory containing argc, the argv array, the environment variable array,</span></span><br><span class="line"><span class="comment">// and the array of ELF aux vectors. This class breaks that block up into its</span></span><br><span class="line"><span class="comment">// constituents for easy access.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KernelArgumentBlock</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">KernelArgumentBlock</span><span class="params">(<span class="keyword">void</span>* raw_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span>* args = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>*&gt;(raw_args);</span><br><span class="line">    argc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(*args);</span><br><span class="line">    argv = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>**&gt;(args + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 此处初始化环境变量</span></span><br><span class="line">    envp = argv + argc + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip over all environment variable definitions to find the aux vector.</span></span><br><span class="line">    <span class="comment">// The end of the environment block is marked by a NULL pointer.</span></span><br><span class="line">    <span class="keyword">char</span>** p = envp;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    ++p; <span class="comment">// Skip the NULL itself.</span></span><br><span class="line"></span><br><span class="line">    auxv = <span class="keyword">reinterpret_cast</span>&lt;ElfW(<span class="keyword">auxv_t</span>)*&gt;(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Similar to ::getauxval but doesn&#x27;t require the libc global variables to be set up,</span></span><br><span class="line">  <span class="comment">// so it&#x27;s safe to call this really early on.</span></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">getauxval</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ElfW(<span class="keyword">auxv_t</span>)* v = auxv; v-&gt;a_type != AT_NULL; ++v) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v-&gt;a_type == type) &#123;</span><br><span class="line">        <span class="keyword">return</span> v-&gt;a_un.a_val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> argc;</span><br><span class="line">  <span class="keyword">char</span>** argv;</span><br><span class="line">  <span class="keyword">char</span>** envp;</span><br><span class="line">  ElfW(<span class="keyword">auxv_t</span>)* auxv;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BIONIC_DISALLOW_COPY_AND_ASSIGN(KernelArgumentBlock);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>查看源码可知原来环境变量紧跟着可执行程序参数<code>argv</code>后面，而可执行文件都是通过<code>exec</code>簇函数调用，最终都进行系统调用 <code>int execve(const char* __file, char* const* __argv, char* const* __envp);</code> 该环境变量默认是继承的父进程</p>
<h2 id="如何设置LD-PRELOAD环境变量"><a href="#如何设置LD-PRELOAD环境变量" class="headerlink" title="如何设置LD_PRELOAD环境变量"></a>如何设置LD_PRELOAD环境变量</h2><p>上面分析通过 <code>putenv</code> 方法确实可以添加<code>LD_PRELOAD</code>环境变量，但是在本进程中执行时机太晚，因为 <code>linker</code> 在启动的时候才获取<code>LD_PRELOAD</code>环境变量，后面就算是设置成功但是也不会触发了，那如何才能生效呢，有以下几种方法</p>
<ol>
<li>在该进程的父进程设置该环境变量，然后再启动该进程，根据继承关系得到该环境变量，由于Android特性所有应用进程都是<code>zygote</code>的子进程，似乎设置<code>zygote</code>进程环境变量比较完美，但实际情况并非如此，见下面分析</li>
<li>使用<code>exec</code>簇函数手动设置程序启动的环境变量，Android Java层<code>Runtime.exec</code>设置环境变量就是使用该方法，只是是<code>fork</code>子进程后在子进程调用<code>exec</code>簇函数</li>
<li>使用<a href="https://developer.android.google.cn/ndk/guides/wrap-script?hl=en">Wrap shell script</a>以全新进程运行程序，参考官网解释</li>
</ol>
<p>接下来分析每种方式，我们的目的是在Hook每个App中的函数。</p>
<ol>
<li>方式1针对非Apk执行（如直接执行可执行文件)等可行，而这相当于在shell中设置环境变量或使用<code>Runtime.exec</code>执行。而正常Apk执行是要经过<code>zygote</code>进程<code>fork</code>，看似在<code>zygote</code>进程设置然后所有APP进程都继承，虽然如此但执行时机已经太晚，因为APP进程从<code>zygote</code>进程<code>fork</code>下来其<code>linker</code>已经初始化执行过了，且<code>zygote</code>连Java环境都已经准备好还预加载了一些代码和资源，因此后续不会在获取<code>LD_PRELOAD</code>环境变量，有关源码如下 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(ZygoteArguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">            FileDescriptor pipeFd, <span class="keyword">boolean</span> isZygote)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * By the time we get here, the native code has closed the two actual Zygote</span></span><br><span class="line"><span class="comment">        * socket connections, and substituted /dev/null in their place.  The LocalSocket</span></span><br><span class="line"><span class="comment">        * objects still need to be closed properly.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        closeSocket();</span><br><span class="line"></span><br><span class="line">        Zygote.setAppProcessName(parsedArgs, TAG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of the postFork event.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不为null则是第三种Wrap shell script情况</span></span><br><span class="line">            WrapperInit.execApplication(parsedArgs.mInvokeWith,</span><br><span class="line">                    parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,</span><br><span class="line">                    VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                    pipeFd, parsedArgs.mRemainingArgs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Should not get here.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;WrapperInit.execApplication unexpectedly returned&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">                <span class="comment">// 这里直接执行初始化跳转至ActivityThread执行</span></span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                        parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                        parsedArgs.mRemainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                        parsedArgs.mRemainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">        String[] args;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            args = Zygote.readArgumentList(mSocketReader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;IOException on command socket&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...略</span><br><span class="line"></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids,</span><br><span class="line">                parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo,</span><br><span class="line">                parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,</span><br><span class="line">                parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mIsTopApp,</span><br><span class="line">                parsedArgs.mPkgDataInfoList, parsedArgs.mWhitelistedDataInfoList,</span><br><span class="line">                parsedArgs.mBindMountAppDataDirs, parsedArgs.mBindMountAppStorageDirs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in child</span></span><br><span class="line">                zygoteServer.setForkChild();</span><br><span class="line"></span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">                serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// In the parent. A pid &lt; 0 indicates a failure and will be handled in</span></span><br><span class="line">                <span class="comment">// handleParentProc.</span></span><br><span class="line">                IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">                childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">                handleParentProc(pid, serverPipeFd);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
 当然还可在<code>init</code>进程设置环境变量，<code>zygote</code>从<code>init</code>进程<code>fork</code>下来则继承该环境变量</li>
<li>使用<code>Runtime.exec</code>执行，该情况的弊端在于本进程无法生效，后续子进程生效，而正常情况APP内执行<code>Runtime.exec</code>也只是启动<code>shell</code>执行一些短暂脚本，因此APK进程并不会被Hook。使用<code>exec</code>簇函数在当前进程执行，那完全是替换当前进程，该方式与方法3是相同道理，只是方法3执行时机是在<code>zygote</code>进程<code>fork</code>后立即执行，而本方式是在<code>App</code>执行自身代码时才能执行，相当于二次重启APP，但在实际APK执行却无法成功</li>
<li>使用<code>Wrap shell script</code>执行，通过文档其最基本脚本如下   <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/system/bin/sh</span></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
 通过执行<code>shell</code>脚本内部也是调用<code>exec</code>簇函数，官方文档<a href="https://developer.android.google.cn/ndk/guides/wrap-script#packaging_wrapsh">打包wrap.sh</a>也要求APK必须是可调试的<code>android:debuggable=&quot;true&quot;</code>，还要设置<code>android:extractNativeLibs=&quot;true&quot;</code>以及将<code>wrap.sh</code>打包到原生库中，这些参数作为启动参数传递给<code>zygote</code>，在<code>Zygote.java</code>中有如下代码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyInvokeWithSystemProperty</span><span class="params">(ZygoteArguments args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.mInvokeWith == <span class="keyword">null</span>) &#123;</span><br><span class="line">        args.mInvokeWith = getWrapProperty(args.mNiceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getWrapProperty</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (appName == <span class="keyword">null</span> || appName.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String propertyValue = SystemProperties.get(<span class="string">&quot;wrap.&quot;</span> + appName);</span><br><span class="line">    <span class="keyword">if</span> (propertyValue != <span class="keyword">null</span> &amp;&amp; !propertyValue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 也就是可以设置全局属性<code>wrap.apppackage</code>来指定<code>Wrap shell script</code>脚本位置方便我们测试。接着上面<code>handleChildProc</code>函数分析，当<code>parsedArgs.mInvokeWith != null</code>执行<code> WrapperInit.execApplication</code>源码如下 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execApplication</span><span class="params">(String invokeWith, String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> targetSdkVersion, String instructionSet, FileDescriptor pipeFd,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] args)</span> </span>&#123;</span><br><span class="line">    StringBuilder command = <span class="keyword">new</span> StringBuilder(invokeWith);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String appProcess;</span><br><span class="line">    <span class="keyword">if</span> (VMRuntime.is64BitInstructionSet(instructionSet)) &#123;</span><br><span class="line">        appProcess = <span class="string">&quot;/system/bin/app_process64&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        appProcess = <span class="string">&quot;/system/bin/app_process32&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    command.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    command.append(appProcess);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate bare minimum of debug information to be able to backtrace through JITed code.</span></span><br><span class="line">    <span class="comment">// We assume that if the invoke wrapper is used, backtraces are desirable:</span></span><br><span class="line">    <span class="comment">//  * The wrap.sh script can only be used by debuggable apps, which would enable this flag</span></span><br><span class="line">    <span class="comment">//    without the script anyway (the fork-zygote path).  So this makes the two consistent.</span></span><br><span class="line">    <span class="comment">//  * The wrap.* property can only be used on userdebug builds and is likely to be used by</span></span><br><span class="line">    <span class="comment">//    developers (e.g. enable debug-malloc), in which case backtraces are also useful.</span></span><br><span class="line">    command.append(<span class="string">&quot; -Xcompiler-option --generate-mini-debug-info&quot;</span>);</span><br><span class="line"></span><br><span class="line">    command.append(<span class="string">&quot; /system/bin --application&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        command.append(<span class="string">&quot; &#x27;--nice-name=&quot;</span>).append(niceName).append(<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    command.append(<span class="string">&quot; com.android.internal.os.WrapperInit &quot;</span>);</span><br><span class="line">    command.append(pipeFd != <span class="keyword">null</span> ? pipeFd.getInt$() : <span class="number">0</span>);</span><br><span class="line">    command.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    command.append(targetSdkVersion);</span><br><span class="line">    Zygote.appendQuotedShellArgs(command, args);</span><br><span class="line">    preserveCapabilities();</span><br><span class="line">    Zygote.execShell(command.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 也就是将我们的<code>Wrap shell script</code>当作shell执行参数，其展开命令如下 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh -c mywrap.sh /system/bin/app_process64 -Xcompiler-option --generate-mini-debug-info /system/bin --application --nice-name=App包名 com.android.internal.os.WrapperInit pipeFd 手机SDK版本 android.app.ActivityThread seq=数字</span><br></pre></td></tr></table></figure>
 其中 <code>android.app.ActivityThread seq=数字</code> 是启动Apk传递过来的参数<code>args</code>，回过头来方式2使用<code>exec</code>构造该执行参数即可。这种方式从<code>app_process</code>启动Apk与启动Java程序类似，只是相应参数，uid，Java环境不同，Apk包含Android上下文而Java程序则不包含。使用<code>app_process</code>执行必然又会需要动态链接，因此重新运行<code>linker</code>使我们设置的环境变量生效。因此我们可以修改<code>Wrap shell script</code>脚本如下 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/system/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> LD_PRELOAD=/data/<span class="built_in">local</span>/tmp/ld-test.so</span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
 设置全局属性<code>setprop wrap.app.package path/to/mywrap.sh</code>,或者直接设置属性<code>setprop wrap.app.package LD_PRELOAD=/data/local/tmp/ld-test.so</code>根据shell命令展开都能生效，<strong>注意预加载so库的位数要与APP位数匹配，脚本和so的执行权限和selinux属性</strong></li>
</ol>
<p>三种方式都有其优劣势，方式1如果在<code>init</code>进程设置环境变量，那么<code>zygote</code>就会包含，进而传染给所有APP，但是同样所有APP都被Hook无法指定APP生效，且修改难度大。方式2使用<code>exec</code>子进程生效而本进程由于执行时机较晚不会成功。方式3则有更多的权限限制及打包限制。</p>
<h2 id="测试-LD-PRELOAD"><a href="#测试-LD-PRELOAD" class="headerlink" title="测试 LD_PRELOAD"></a>测试 LD_PRELOAD</h2><p>方式1 <code>init</code>进程注入其结果显而易见且操作困难（解锁<code>boot.img</code>，修改<code>init</code>/<code>启动脚本.rc</code>等总之要在很早的时机拿到执行权限，可以通过<code>Magisk</code>实现，这里不做讲解，当然也可以重新编译源码模拟测试）因此不做测试。</p>
<p>方式2 <code>Runtime.exec</code>子进程生效不做测试</p>
<p>方式3 设置<code>Wrap shell script</code>测试如下，为了方便直接设置全局属性<code>wrap.app.package=mywrap.sh</code>预加载库<code>ld-test.so</code>源码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hook_module.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_API extern <span class="meta-string">&quot;C&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUBLIC_METHOD __attribute__ ((visibility (<span class="meta-string">&quot;default&quot;</span>)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(format, ...) __android_log_print(ANDROID_LOG_DEBUG, <span class="meta-string">&quot;PreloadTest&quot;</span>, format, ##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="function">C_API PUBLIC_METHOD <span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*orig_access)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span> </span>= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (orig_access == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *libc = dlopen(<span class="string">&quot;libc.so&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (libc == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        orig_access = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> (*)(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)&gt;(dlsym(libc, <span class="string">&quot;access&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (orig_access == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 避免陷入死循环,高版本调用__android_log_print会访问access函数请求/dev/socket/logdw权限</span></span><br><span class="line">    <span class="comment">// 因此此时再调用__android_log_print则会陷入死循环</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;/dev/socket/logdw&quot;</span>, pathname) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> orig_access(pathname, mode);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGD(<span class="string">&quot;Hook模块监听access函数,路径: %s, mode: %d&quot;</span>, pathname, mode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;/data/local/tmp/ld-test.txt&quot;</span>, pathname) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果是我们测试文件访问则返回-1没有该文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orig_access(pathname, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGD(<span class="string">&quot;LD_PRELOAD模块被加载&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java相关源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sfandroid.nativehook.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.sfandroid.nativehook.test.databinding.ActivityMainBinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">        setContentView(binding.getRoot());</span><br><span class="line">        findViewById(R.id.btn_test).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        findViewById(R.id.btn_test1).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">execShell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn_test:</span><br><span class="line"><span class="comment">//                stringFromJNI();</span></span><br><span class="line">                Log.d(<span class="string">&quot;PreloadTest&quot;</span>, <span class="string">&quot;文件存在: &quot;</span> + <span class="keyword">new</span> File(<span class="string">&quot;/data/local/tmp/ld-test.txt&quot;</span>).exists());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn_test1:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    execShell();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;PreloadTest&quot;</span>, <span class="string">&quot;执行错误&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Android11官方x86_64模拟器，测试64位，将预加载库库放至<code>/data/local/tmp</code>目录下，并创建<code>data/local/tmp/ld-test.txt</code>测试文件，关闭<code>selinux</code>方便后续测试，命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb push path/to/ld-test.so /data/<span class="built_in">local</span>/tmp</span><br><span class="line">adb shell touch /data/<span class="built_in">local</span>/tmp/ld-test.txt</span><br><span class="line">adb shell chmod 777 /data/<span class="built_in">local</span>/tmp/libld-test.so</span><br><span class="line">adb shell chmod 666 /data/<span class="built_in">local</span>/tmp/ld-test.txt</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure>
<p>当我们未设置<code>wrap.org.sfandroid.nativehook.test</code>属性时执行测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7667-7667&#x2F;? D&#x2F;PreloadTest: 文件存在: true</span><br></pre></td></tr></table></figure>
<p>上面我们创建了测试文件因此它是真实存在的而当我们执行<code>adb shell setprop wrap.org.sfandroid.nativehook.test &quot;LD_PRELOAD=/data/local/tmp/libld-test.so&quot;</code>后重新运行APP测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: Hook模块监听access函数,路径: &#x2F;dev&#x2F;urandom, mode: 4</span><br><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: Hook模块监听access函数,路径: &#x2F;dev&#x2F;__properties__&#x2F;property_info, mode: 4</span><br><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: LD_PRELOAD模块被加载</span><br><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: Hook模块监听access函数,路径: &#x2F;dev&#x2F;boringssl&#x2F;selftest&#x2F;1cca4bc9f53317a49929af0b9283b0f20d38a542739d7db04ff0aa7ca9b9dcd1, mode: 0</span><br><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: Hook模块监听access函数,路径: &#x2F;dev&#x2F;boringssl&#x2F;selftest&#x2F;1cca4bc9f53317a49929af0b9283b0f20d38a542739d7db04ff0aa7ca9b9dcd1, mode: 0</span><br><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: Hook模块监听access函数,路径: &#x2F;vendor&#x2F;overlay, mode: 0</span><br><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: Hook模块监听access函数,路径: &#x2F;vendor&#x2F;overlay&#x2F;config&#x2F;config.xml, mode: 0</span><br><span class="line"></span><br><span class="line">...省略部分</span><br><span class="line"></span><br><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: Hook模块监听access函数,路径: &#x2F;data&#x2F;local&#x2F;tmp&#x2F;ld-test.txt, mode: 0</span><br><span class="line">7806-7806&#x2F;? D&#x2F;PreloadTest: 文件存在: false</span><br></pre></td></tr></table></figure>
<p>可以看到<code>libld-test.so</code>确实被首先加载，并影响了Java层调用<code>File.exist</code>（native层调用access函数）结果，从而达到屏蔽的效果。</p>
<p>我们尝试了<code>wrap.sh</code>脚本方式需要设置环境变量或指定打包那么再测试一下直接构造<code>exec</code>执行参数试试，跟踪<code>Zygote.exeShell</code>最终调用<code>execv</code>函数，而它<code>return execve(name, argv, environ);</code>，因此只需要将<code>LD_PRELOAD</code>添加到当前进程环境变量然后调用<code>execv</code>函数即可，有关native代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_org_sfandroid_nativehook_test_MainActivity_execShell(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    <span class="keyword">char</span> *ld_preload = getenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ld_preload != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经包含了LD_PRELOAD环境变量则不用再执行了</span></span><br><span class="line">        LOGD(<span class="string">&quot;已经存在LD_PRELOAD变量: %s&quot;</span>, ld_preload);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    putenv((<span class="keyword">char</span> *) <span class="string">&quot;LD_PRELOAD=/data/local/tmp/libld-test.so&quot;</span>);</span><br><span class="line">    <span class="comment">// pipeFd是开机后的一个socket文件写入，只要不重启该值不会变，为了方便本次设备为40固定即可</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *args[] = &#123;<span class="string">&quot;/system/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;/system/bin/app_process64 -Xcompiler-option --generate-mini-debug-info /system/bin --application --nice-name=org.sfandroid.nativehook.test com.android.internal.os.WrapperInit 40 30 android.app.ActivityThread seq=130&quot;</span>,</span><br><span class="line">                          <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    execv(args[<span class="number">0</span>], (<span class="keyword">char</span> *<span class="keyword">const</span> *) args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就相当于手动执行<code>wrap.sh</code>脚本，只是时间在App应用执行时，原理虽然通过但是执行却得到以下结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">596-789/? W/InputDispatcher: channel <span class="string">&#x27;7c0090b org.sfandroid.nativehook.test/org.sfandroid.nativehook.test.MainActivity (server)&#x27;</span> ~ Consumer closed input channel or an error occurred.  events=0x9</span><br><span class="line">596-789/? E/InputDispatcher: channel <span class="string">&#x27;7c0090b org.sfandroid.nativehook.test/org.sfandroid.nativehook.test.MainActivity (server)&#x27;</span> ~ Channel is unrecoverably broken and will be disposed!</span><br><span class="line">596-2056/? I/system_server: oneway <span class="keyword">function</span> results will be dropped but finished with status OK and parcel size 4</span><br><span class="line">0-0/? I/binder: undelivered TRANSACTION_COMPLETE</span><br><span class="line">0-0/? I/binder: undelivered transaction 858386, process died.</span><br><span class="line">9687-9687/? D/PreloadTest: Hook模块监听access函数,路径: /dev/urandom, mode: 4</span><br><span class="line">9687-9687/? D/PreloadTest: Hook模块监听access函数,路径: /dev/__properties__/property_info, mode: 4</span><br><span class="line">9687-9687/? D/PreloadTest: LD_PRELOAD模块被加载</span><br><span class="line">9687-9687/? D/PreloadTest: Hook模块监听access函数,路径: /system/bin/app_process64, mode: 1</span><br><span class="line">596-2930/? I/WindowManager: WIN DEATH: Window&#123;7c0090b u0 org.sfandroid.nativehook.test/org.sfandroid.nativehook.test.MainActivity&#125;</span><br><span class="line">596-2930/? W/InputDispatcher: Attempted to unregister already unregistered input channel <span class="string">&#x27;7c0090b org.sfandroid.nativehook.test/org.sfandroid.nativehook.test.MainActivity (server)&#x27;</span></span><br><span class="line">596-2921/? I/ActivityManager: Process org.sfandroid.nativehook.test (pid 9687) has died: <span class="built_in">fg</span>  TOP </span><br><span class="line">9687-9687/? I/sh: <span class="built_in">type</span>=1400 audit(0.0:180): avc: denied &#123; execute &#125; <span class="keyword">for</span> path=<span class="string">&quot;/data/local/tmp/libld-test.so&quot;</span> dev=<span class="string">&quot;dm-5&quot;</span> ino=65540 scontext=u:r:untrusted_app:s0:c153,c256,c512,c768 tcontext=u:object_r:shell_data_file:s0 tclass=file permissive=1 app=org.sfandroid.nativehook.test</span><br><span class="line">300-300/? I/Zygote: Process 9687 exited due to signal 9 (Killed)</span><br><span class="line">596-2056/? I/system_server: oneway <span class="keyword">function</span> results will be dropped but finished with status OK and parcel size 4</span><br><span class="line">0-0/? I/init: Untracked pid 9723 received signal 9</span><br><span class="line">596-2921/? W/ActivityTaskManager: Force removing ActivityRecord&#123;c639d07 u0 org.sfandroid.nativehook.test/.MainActivity t34&#125;: app died, no saved state</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ActivityManager: Process org.sfandroid.nativehook.test (pid 9687) has died: fg  TOP </code>最终进程会死亡被<code>kill</code>掉，当然你有可能看不到<code>PreloadTest: LD_PRELOAD模块被加载</code>该日志，因为进程过早就被杀死掉了，多次尝试可能会查看到（我也试了很多次才出现），这证明<code>exec</code>执行确实我们的环境变量已生效，只是因为其它原因被杀死而已。这与<code>wrap.sh</code>方式相同只是执行时机一个在<code>zygote fork</code>后就执行，一个在APP启动后才执行，而之所以被杀也不难猜测，因为APP环境全部都准备好的<code>system_server</code>里已经包含该APP的进程信息，而我们执行<code>execv</code>又把这些数据给清除掉了，这理所当然会被<code>system_server</code>认为APP可能已经死亡了因此被杀死。而在<code>zygote fork</code>后执行该APP环境根本还未执行，<code>system_server</code>没有它的记录，因此可以成功。具体原因可以分析源码，这里就不分析了，因为这离我们主题更远，且我们不走这条路径。</p>
<p>综上分析可实现的路径要么在父进程设置子进程生效要么就设置<code>Wrap shell script</code>，而我们针对APP指定进程生效最简单方法是设置<code>wrap.app.package</code>全局属性，但同时也需要root权限，注入<code>init</code>进程太麻烦也无法指定APP生效。即使<code>LD_PRELOAD</code>生效我们也无法在Hook模块内拦截<code>dlopen,dlsym</code>等函数，因为我们Hook模块内部要使用它获取原函数地址，就算自己实现<code>dlopen,dlsym</code>函数但是在Android7.0以上的命名空间限制<code>caller</code>的地址都变成我们的Hook模块内的地址，那么跨命名空间调用就会存在问题。</p>
<p>经过以上分析引入了我们本文章的主题 <strong>动态修改Linker实现LD_PRELOAD效果</strong> 该方式避免了上面的缺点，优点如下</p>
<ol>
<li>APP进程内生效，可以指定进程</li>
<li>可以重打包到APP内部无需权限，也可进程注入</li>
<li>可以HOOK指定模块（如<code>libandroid-runtime.so</code>等）</li>
<li>可以Hook <code>dlopen,dlsym</code>等符号，不受命名空间限制</li>
<li>进程<code>fork</code>子进程默认继承</li>
</ol>
<h2 id="LD-PRELOAD原理分析"><a href="#LD-PRELOAD原理分析" class="headerlink" title="LD_PRELOAD原理分析"></a><code>LD_PRELOAD</code>原理分析</h2><p>上面已经分析过在<code>linker_main</code>函数中获取该环境变量，紧接着往下分析</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">ElfW</span><span class="params">(Addr)</span> <span class="title">linker_main</span><span class="params">(KernelArgumentBlock&amp; args, <span class="keyword">const</span> <span class="keyword">char</span>* exe_to_load)</span> </span>&#123;</span><br><span class="line">  ...省略</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!getauxval(AT_SECURE)) &#123;</span><br><span class="line">    ldpath_env = getenv(<span class="string">&quot;LD_LIBRARY_PATH&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ldpath_env != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      INFO(<span class="string">&quot;[ LD_LIBRARY_PATH set to \&quot;%s\&quot; ]&quot;</span>, ldpath_env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取该环境变量</span></span><br><span class="line">    ldpreload_env = getenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ldpreload_env != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      INFO(<span class="string">&quot;[ LD_PRELOAD set to \&quot;%s\&quot; ]&quot;</span>, ldpreload_env);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use LD_LIBRARY_PATH and LD_PRELOAD (but only if we aren&#x27;t setuid/setgid).</span></span><br><span class="line">  parse_LD_LIBRARY_PATH(ldpath_env);</span><br><span class="line">  <span class="comment">// 解析环境变量</span></span><br><span class="line">  parse_LD_PRELOAD(ldpreload_env);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">android_namespace_t</span>*&gt; namespaces = init_default_namespaces(exe_info.path.c_str());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!si-&gt;prelink_image()) __linker_cannot_link(g_argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add somain to global group</span></span><br><span class="line">  si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);</span><br><span class="line">  <span class="comment">// ... and add it to all other linked namespaces</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> linked_ns : namespaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (linked_ns != &amp;g_default_namespace) &#123;</span><br><span class="line">      linked_ns-&gt;add_soinfo(somain);</span><br><span class="line">      somain-&gt;add_secondary_namespace(linked_ns);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  linker_setup_exe_static_tls(g_argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load ld_preloads and dependencies.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; needed_library_name_list;</span><br><span class="line">  <span class="keyword">size_t</span> ld_preloads_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将预加载模块作为库的依赖最先添加到加载任务队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; ld_preload_name : g_ld_preload_names) &#123;</span><br><span class="line">    needed_library_name_list.push_back(ld_preload_name.c_str());</span><br><span class="line">    ++ld_preloads_count;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其次才添加可执行文件的依赖项</span></span><br><span class="line">  for_each_dt_needed(si, [&amp;](<span class="keyword">const</span> <span class="keyword">char</span>* name) &#123;</span><br><span class="line">    needed_library_name_list.push_back(name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>** needed_library_names = &amp;needed_library_name_list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">size_t</span> needed_libraries_count = needed_library_name_list.size();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用find_libraries加载库</span></span><br><span class="line">  <span class="keyword">if</span> (needed_libraries_count &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      !find_libraries(&amp;g_default_namespace,</span><br><span class="line">                      si,</span><br><span class="line">                      needed_library_names,</span><br><span class="line">                      needed_libraries_count,</span><br><span class="line">                      <span class="literal">nullptr</span>,</span><br><span class="line">                      &amp;g_ld_preloads,</span><br><span class="line">                      ld_preloads_count,</span><br><span class="line">                      RTLD_GLOBAL,</span><br><span class="line">                      <span class="literal">nullptr</span>,</span><br><span class="line">                      <span class="literal">true</span> <span class="comment">/* add_as_children */</span>,</span><br><span class="line">                      &amp;namespaces)) &#123;</span><br><span class="line">    __linker_cannot_link(g_argv[<span class="number">0</span>]);</span><br><span class="line">  &#125; </span><br><span class="line">  ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面分析<code>LD_PRELOAD</code>库最先添加到加载队列，然后调用<code>find_libraries</code>执行加载，此时<code>needed_library_names</code>最前面的元素就是预加载库，继续查看源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ns                                加载的命名空间=调用者的命名空间</span></span><br><span class="line"><span class="comment">    start_with                        调用者的soinfo</span></span><br><span class="line"><span class="comment">    library_names                     所有加载库名称</span></span><br><span class="line"><span class="comment">    library_names_count               加载库数量</span></span><br><span class="line"><span class="comment">    soinfos                           保存加载完成的soinfo</span></span><br><span class="line"><span class="comment">    ld_preloads                       保存预加载库,没有可以为null</span></span><br><span class="line"><span class="comment">    ld_preloads_count                 预加载库数量</span></span><br><span class="line"><span class="comment">    extinfo                           Android调用附带</span></span><br><span class="line"><span class="comment">    add_as_children                   是否作为start_with的子库</span></span><br><span class="line"><span class="comment">    search_linked_namespaces          查询链接命名空间</span></span><br><span class="line"><span class="comment">    namespaces                        链接命名空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_libraries</span><span class="params">(<span class="keyword">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="function"><span class="params">                    soinfo* start_with,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> library_names[],</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">size_t</span> library_names_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                    soinfo* soinfos[],</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;soinfo*&gt;* ld_preloads,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">size_t</span> ld_preloads_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">bool</span> add_as_children,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">android_namespace_t</span>*&gt;* namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Step 0: prepare.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">const</span> soinfo*, ElfReader&gt; readers_map;</span><br><span class="line">  LoadTaskList load_tasks;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; library_names_count; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = library_names[i];</span><br><span class="line">    load_tasks.push_back(LoadTask::create(name, start_with, ns, &amp;readers_map));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If soinfos array is null allocate one on stack.</span></span><br><span class="line">  <span class="comment">// The array is needed in case of failure; for example</span></span><br><span class="line">  <span class="comment">// when library_names[] = &#123;libone.so, libtwo.so&#125; and libone.so</span></span><br><span class="line">  <span class="comment">// is loaded correctly but libtwo.so failed for some reason.</span></span><br><span class="line">  <span class="comment">// In this case libone.so should be unloaded on return.</span></span><br><span class="line">  <span class="comment">// See also implementation of failure_guard below.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (soinfos == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> soinfos_size = <span class="keyword">sizeof</span>(soinfo*)*library_names_count;</span><br><span class="line">    soinfos = <span class="keyword">reinterpret_cast</span>&lt;soinfo**&gt;(alloca(soinfos_size));</span><br><span class="line">    <span class="built_in">memset</span>(soinfos, <span class="number">0</span>, soinfos_size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// list of libraries to link - see step 2.</span></span><br><span class="line">  <span class="keyword">size_t</span> soinfos_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> scope_guard = android::base::make_scope_guard([&amp;]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (LoadTask* t : load_tasks) &#123;</span><br><span class="line">      LoadTask::deleter(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ZipArchiveCache zip_archive_cache;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 1: expand the list of load_tasks to include</span></span><br><span class="line">  <span class="comment">// all DT_NEEDED libraries (do not load them just yet)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i&lt;load_tasks.size(); ++i) &#123;</span><br><span class="line">    LoadTask* task = load_tasks[i];</span><br><span class="line">    soinfo* needed_by = task-&gt;get_needed_by();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> is_dt_needed = needed_by != <span class="literal">nullptr</span> &amp;&amp; (needed_by != start_with || add_as_children);</span><br><span class="line">    task-&gt;set_extinfo(is_dt_needed ? <span class="literal">nullptr</span> : extinfo);</span><br><span class="line">    task-&gt;set_dt_needed(is_dt_needed);</span><br><span class="line"></span><br><span class="line">    LD_LOG(kLogDlopen, <span class="string">&quot;find_libraries(ns=%s): task=%s, is_dt_needed=%d&quot;</span>, ns-&gt;get_name(),</span><br><span class="line">           task-&gt;get_name(), is_dt_needed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: start from the namespace that is stored in the LoadTask. This namespace</span></span><br><span class="line">    <span class="comment">// is different from the current namespace when the LoadTask is for a transitive</span></span><br><span class="line">    <span class="comment">// dependency and the lib that created the LoadTask is not found in the</span></span><br><span class="line">    <span class="comment">// current namespace but in one of the linked namespace.</span></span><br><span class="line">    <span class="keyword">if</span> (!find_library_internal(<span class="keyword">const_cast</span>&lt;<span class="keyword">android_namespace_t</span>*&gt;(task-&gt;get_start_from()),</span><br><span class="line">                               task,</span><br><span class="line">                               &amp;zip_archive_cache,</span><br><span class="line">                               &amp;load_tasks,</span><br><span class="line">                               rtld_flags)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    soinfo* si = task-&gt;get_soinfo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_dt_needed) &#123;</span><br><span class="line">      needed_by-&gt;add_child(si);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When ld_preloads is not null, the first</span></span><br><span class="line">    <span class="comment">// ld_preloads_count libs are in fact ld_preloads.</span></span><br><span class="line">    <span class="comment">// 如果预加载库不为空则保存到ld_preloads中</span></span><br><span class="line">    <span class="keyword">if</span> (ld_preloads != <span class="literal">nullptr</span> &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;</span><br><span class="line">      ld_preloads-&gt;push_back(si);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (soinfos_count &lt; library_names_count) &#123;</span><br><span class="line">      soinfos[soinfos_count++] = si;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一步已经完成so的加载，并都存在对应的soinfo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 2: Load libraries in random order (see b/24047022)</span></span><br><span class="line">  LoadTaskList load_list;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;get_soinfo();</span><br><span class="line">    <span class="keyword">auto</span> pred = [&amp;](<span class="keyword">const</span> LoadTask* t) &#123;</span><br><span class="line">      <span class="keyword">return</span> t-&gt;get_soinfo() == si;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 库还未链接则添加到加载列表</span></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;is_linked() &amp;&amp;</span><br><span class="line">        <span class="built_in">std</span>::find_if(load_list.begin(), load_list.end(), pred) == load_list.end() ) &#123;</span><br><span class="line">      load_list.push_back(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 3: pre-link all DT_NEEDED libraries in breadth first order.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;get_soinfo();</span><br><span class="line">    <span class="comment">// 第三步预链接解析所有Dynamic Section</span></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;is_linked() &amp;&amp; !si-&gt;prelink_image()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    register_soinfo_tls(si);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 4: Construct the global group. Note: DF_1_GLOBAL bit of a library is</span></span><br><span class="line">  <span class="comment">// determined at step 3.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 4-1: DF_1_GLOBAL bit is force set for LD_PRELOADed libs because they</span></span><br><span class="line">  <span class="comment">// must be added to the global group</span></span><br><span class="line">  <span class="comment">// 第四步构造全局组，这里使用了上面的预加载库，设置全局标志</span></span><br><span class="line">  <span class="keyword">if</span> (ld_preloads != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; si : *ld_preloads) &#123;</span><br><span class="line">      si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 4-2: Gather all DF_1_GLOBAL libs which were newly loaded during this</span></span><br><span class="line">  <span class="comment">// run. These will be the new member of the global group</span></span><br><span class="line">  <span class="keyword">soinfo_list_t</span> new_global_group_members;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;get_soinfo();</span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;is_linked() &amp;&amp; (si-&gt;get_dt_flags_1() &amp; DF_1_GLOBAL) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 本次加载的全局库作为新的全局组</span></span><br><span class="line">      new_global_group_members.push_back(si);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 4-3: Add the new global group members to all the linked namespaces</span></span><br><span class="line">  <span class="keyword">if</span> (namespaces != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> linked_ns : *namespaces) &#123;</span><br><span class="line">        <span class="comment">// 将新的全局组添加到所有链接命名空间</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> si : new_global_group_members) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;get_primary_namespace() != linked_ns) &#123;</span><br><span class="line">          linked_ns-&gt;add_soinfo(si);</span><br><span class="line">          si-&gt;add_secondary_namespace(linked_ns);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 5: Collect roots of local_groups.</span></span><br><span class="line">  <span class="comment">// Whenever needed_by-&gt;si link crosses a namespace boundary it forms its own local_group.</span></span><br><span class="line">  <span class="comment">// Here we collect new roots to link them separately later on. Note that we need to avoid</span></span><br><span class="line">  <span class="comment">// collecting duplicates. Also the order is important. They need to be linked in the same</span></span><br><span class="line">  <span class="comment">// BFS order we link individual libraries.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;soinfo*&gt; local_group_roots;</span><br><span class="line">  <span class="keyword">if</span> (start_with != <span class="literal">nullptr</span> &amp;&amp; add_as_children) &#123;</span><br><span class="line">    local_group_roots.push_back(start_with);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CHECK(soinfos_count == <span class="number">1</span>);</span><br><span class="line">    local_group_roots.push_back(soinfos[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;get_soinfo();</span><br><span class="line">    soinfo* needed_by = task-&gt;get_needed_by();</span><br><span class="line">    <span class="keyword">bool</span> is_dt_needed = needed_by != <span class="literal">nullptr</span> &amp;&amp; (needed_by != start_with || add_as_children);</span><br><span class="line">    <span class="keyword">android_namespace_t</span>* needed_by_ns =</span><br><span class="line">        is_dt_needed ? needed_by-&gt;get_primary_namespace() : ns;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() != needed_by_ns) &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = <span class="built_in">std</span>::find(local_group_roots.begin(), local_group_roots.end(), si);</span><br><span class="line">      LD_LOG(kLogDlopen,</span><br><span class="line">             <span class="string">&quot;Crossing namespace boundary (si=%s@%p, si_ns=%s@%p, needed_by=%s@%p, ns=%s@%p, needed_by_ns=%s@%p) adding to local_group_roots: %s&quot;</span>,</span><br><span class="line">             si-&gt;get_realpath(),</span><br><span class="line">             si,</span><br><span class="line">             si-&gt;get_primary_namespace()-&gt;get_name(),</span><br><span class="line">             si-&gt;get_primary_namespace(),</span><br><span class="line">             needed_by == <span class="literal">nullptr</span> ? <span class="string">&quot;(nullptr)&quot;</span> : needed_by-&gt;get_realpath(),</span><br><span class="line">             needed_by,</span><br><span class="line">             ns-&gt;get_name(),</span><br><span class="line">             ns,</span><br><span class="line">             needed_by_ns-&gt;get_name(),</span><br><span class="line">             needed_by_ns,</span><br><span class="line">             it == local_group_roots.end() ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (it == local_group_roots.end()) &#123;</span><br><span class="line">        local_group_roots.push_back(si);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 6: Link all local groups</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> root : local_group_roots) &#123;</span><br><span class="line">    <span class="keyword">soinfo_list_t</span> local_group;</span><br><span class="line">    <span class="keyword">android_namespace_t</span>* local_group_ns = root-&gt;get_primary_namespace();</span><br><span class="line"></span><br><span class="line">    walk_dependencies_tree(root,</span><br><span class="line">      [&amp;] (soinfo* si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (local_group_ns-&gt;is_accessible(si)) &#123;</span><br><span class="line">          local_group.push_back(si);</span><br><span class="line">          <span class="keyword">return</span> kWalkContinue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> kWalkSkip;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全局组包含的soinfo，因为预加载库是一起加载的跟local_group_ns是同一个命名空间</span></span><br><span class="line">    <span class="comment">// 所有这里的全局组已经包含了预加载库</span></span><br><span class="line">    <span class="keyword">soinfo_list_t</span> global_group = local_group_ns-&gt;get_global_group();</span><br><span class="line">    <span class="function">SymbolLookupList <span class="title">lookup_list</span><span class="params">(global_group, local_group)</span></span>;</span><br><span class="line">    soinfo* local_group_root = local_group.front();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> linked = local_group.visit([&amp;](soinfo* si) &#123;</span><br><span class="line">      <span class="comment">// Even though local group may contain accessible soinfos from other namespaces</span></span><br><span class="line">      <span class="comment">// we should avoid linking them (because if they are not linked -&gt; they</span></span><br><span class="line">      <span class="comment">// are in the local_group_roots and will be linked later).</span></span><br><span class="line">      <span class="keyword">if</span> (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() == local_group_ns) &#123;</span><br><span class="line">        <span class="keyword">const</span> android_dlextinfo* link_extinfo = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (si == soinfos[<span class="number">0</span>] || reserved_address_recursive) &#123;</span><br><span class="line">          <span class="comment">// Only forward extinfo for the first library unless the recursive</span></span><br><span class="line">          <span class="comment">// flag is set.</span></span><br><span class="line">          link_extinfo = extinfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__libc_shared_globals()-&gt;load_hook) &#123;</span><br><span class="line">          __libc_shared_globals()-&gt;load_hook(si-&gt;load_bias, si-&gt;phdr, si-&gt;phnum);</span><br><span class="line">        &#125;</span><br><span class="line">        lookup_list.set_dt_symbolic_lib(si-&gt;has_DT_SYMBOLIC ? si : <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 链接库使用上面的lookup_list</span></span><br><span class="line">        <span class="keyword">if</span> (!si-&gt;link_image(lookup_list, local_group_root, link_extinfo, &amp;relro_fd_offset) ||</span><br><span class="line">            !get_cfi_shadow()-&gt;AfterLoad(si, solist_get_head())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!linked) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经上面代码注释了解到预加载库作为首先加载的库，且库调用<code>si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);</code>设置了<code>DF_1_GLOBAL</code>标志，后续再将全局库添加到它所有的链接命名空间内</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (namespaces != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> linked_ns : *namespaces) &#123;</span><br><span class="line">        <span class="comment">// 将新的全局组添加到所有链接命名空间</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> si : new_global_group_members) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;get_primary_namespace() != linked_ns) &#123;</span><br><span class="line">          linked_ns-&gt;add_soinfo(si);</span><br><span class="line">          si-&gt;add_secondary_namespace(linked_ns);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取全局库就是根据 DF_1_GLOBAL 来获取</span></span><br><span class="line">  <span class="function"><span class="keyword">soinfo_list_t</span> <span class="title">android_namespace_t::get_global_group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">soinfo_list_t</span> global_group;</span><br><span class="line">  soinfo_list().for_each([&amp;](soinfo* si) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((si-&gt;get_dt_flags_1() &amp; DF_1_GLOBAL) != <span class="number">0</span>) &#123;</span><br><span class="line">      global_group.push_back(si);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> global_group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们后面添加全局库就按照这个步骤来，后续查找符号时全局库集合调用<code>local_group_ns-&gt;get_global_group();</code>，因为我们本身加载的全局库跟待加载的库都在一个命名空间所以这里包含了我们的全局库，接下来开始链接库<code>si-&gt;link_image(lookup_list, local_group_root, link_extinfo, &amp;relro_fd_offset) ||!get_cfi_shadow()-&gt;AfterLoad(si, solist_get_head())</code> 其中<code>lookup_list</code>包含了全局组和本地组，其中<code>link_image</code>中调用了<code>relocate(lookup_list)</code>来重定向库的导入符号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">soinfo::link_image</span><span class="params">(<span class="keyword">const</span> SymbolLookupList&amp; lookup_list, soinfo* local_group_root,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> android_dlextinfo* extinfo, <span class="keyword">size_t</span>* relro_fd_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_image_linked()) &#123;</span><br><span class="line">    <span class="comment">// already linked.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_is_ldd &amp;&amp; !is_main_executable()) &#123;</span><br><span class="line">    async_safe_format_fd(STDOUT_FILENO, <span class="string">&quot;\t%s =&gt; %s (%p)\n&quot;</span>, get_soname(),</span><br><span class="line">                         get_realpath(), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(base));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  local_group_root_ = local_group_root;</span><br><span class="line">  <span class="keyword">if</span> (local_group_root_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    local_group_root_ = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((flags_ &amp; FLAG_LINKER) == <span class="number">0</span> &amp;&amp; local_group_root_ == <span class="keyword">this</span>) &#123;</span><br><span class="line">    target_sdk_version_ = get_application_target_sdk_version();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!relocate(lookup_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符号重定向源码分析</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">soinfo::relocate</span><span class="params">(<span class="keyword">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  VersionTracker version_tracker;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!version_tracker.init(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Relocator <span class="title">relocator</span><span class="params">(version_tracker, lookup_list)</span></span>;</span><br><span class="line">  relocator.si = <span class="keyword">this</span>;</span><br><span class="line">  relocator.si_strtab = strtab_;</span><br><span class="line">  relocator.si_strtab_size = has_min_version(<span class="number">1</span>) ? strtab_size_ : SIZE_MAX;</span><br><span class="line">  relocator.si_symtab = symtab_;</span><br><span class="line">  relocator.tlsdesc_args = &amp;tlsdesc_args_;</span><br><span class="line">  relocator.tls_tp_base = __libc_shared_globals()-&gt;static_tls_layout.offset_thread_pointer();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (android_relocs_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// check signature</span></span><br><span class="line">    <span class="keyword">if</span> (android_relocs_size_ &gt; <span class="number">3</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">1</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">2</span>] == <span class="string">&#x27;S&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">3</span>] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">      DEBUG(<span class="string">&quot;[ android relocating %s ]&quot;</span>, get_realpath());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint8_t</span>* packed_relocs = android_relocs_ + <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">size_t</span> packed_relocs_size = android_relocs_size_ - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!packed_relocate&lt;RelocMode::Typical&gt;(relocator, sleb128_decoder(packed_relocs, packed_relocs_size))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      DL_ERR(<span class="string">&quot;bad android relocation header.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (relr_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;[ relocating %s relr ]&quot;</span>, get_realpath());</span><br><span class="line">    <span class="keyword">if</span> (!relocate_relr()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// rela重定向</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">  <span class="keyword">if</span> (rela_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;[ relocating %s rela ]&quot;</span>, get_realpath());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!plain_relocate&lt;RelocMode::Typical&gt;(relocator, rela_, rela_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (plt_rela_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;[ relocating %s plt rela ]&quot;</span>, get_realpath());</span><br><span class="line">    <span class="keyword">if</span> (!plain_relocate&lt;RelocMode::JumpTable&gt;(relocator, plt_rela_, plt_rela_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// rel重定向</span></span><br><span class="line">  <span class="keyword">if</span> (rel_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;[ relocating %s rel ]&quot;</span>, get_realpath());</span><br><span class="line">    <span class="keyword">if</span> (!plain_relocate&lt;RelocMode::Typical&gt;(relocator, rel_, rel_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (plt_rel_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;[ relocating %s plt rel ]&quot;</span>, get_realpath());</span><br><span class="line">    <span class="keyword">if</span> (!plain_relocate&lt;RelocMode::JumpTable&gt;(relocator, plt_rel_, plt_rel_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the tlsdesc_args_ vector&#x27;s size is finalized, we can write the addresses of its elements</span></span><br><span class="line">  <span class="comment">// into the TLSDESC relocations.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__aarch64__)</span></span><br><span class="line">  <span class="comment">// Bionic currently only implements TLSDESC for arm64.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;TlsDescriptor*, <span class="keyword">size_t</span>&gt;&amp; <span class="built_in">pair</span> : relocator.deferred_tlsdesc_relocs) &#123;</span><br><span class="line">    TlsDescriptor* desc = <span class="built_in">pair</span>.first;</span><br><span class="line">    desc-&gt;func = tlsdesc_resolver_dynamic;</span><br><span class="line">    desc-&gt;arg = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">size_t</span>&gt;(&amp;tlsdesc_args_[<span class="built_in">pair</span>.second]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用 <code>plain_relocate()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;RelocMode OptMode, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">plain_relocate</span><span class="params">(Relocator&amp; relocator, Args ...args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> needs_slow_relocate_loop(relocator) ?</span><br><span class="line">      plain_relocate_impl&lt;RelocMode::General&gt;(relocator, args...) :</span><br><span class="line">      plain_relocate_impl&lt;OptMode&gt;(relocator, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">plain_relocate_impl</span><span class="params">(Relocator&amp; relocator, <span class="keyword">rel_t</span>* rels, <span class="keyword">size_t</span> rel_count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; rel_count; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!process_relocation&lt;Mode&gt;(relocator, rels[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">process_relocation</span><span class="params">(Relocator&amp; relocator, <span class="keyword">const</span> <span class="keyword">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mode == RelocMode::General ?</span><br><span class="line">      process_relocation_general(relocator, reloc) :</span><br><span class="line">      process_relocation_impl&lt;Mode&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">process_relocation_general</span><span class="params">(Relocator&amp; relocator, <span class="keyword">const</span> <span class="keyword">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> process_relocation_impl&lt;RelocMode::General&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终实现符号重定向是在<code>process_relocation_impl</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">process_relocation_impl</span><span class="params">(Relocator&amp; relocator, <span class="keyword">const</span> <span class="keyword">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> IsGeneral = Mode == RelocMode::General;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* <span class="keyword">const</span> rel_target = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(reloc.r_offset + relocator.si-&gt;load_bias);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> r_type = ELFW(R_TYPE)(reloc.r_info);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> r_sym = ELFW(R_SYM)(reloc.r_info);</span><br><span class="line"></span><br><span class="line">  soinfo* found_in = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* sym </span>= <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* sym_name = <span class="literal">nullptr</span>;</span><br><span class="line">  ElfW(Addr) sym_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r_sym != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取重定向的符号名</span></span><br><span class="line">    sym_name = relocator.get_string(relocator.si_symtab[r_sym].st_name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ...省略</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">  <span class="keyword">auto</span> get_addend_rel   = [&amp;]() -&gt; ElfW(Addr) &#123; <span class="keyword">return</span> reloc.r_addend; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> get_addend_norel = [&amp;]() -&gt; ElfW(Addr) &#123; <span class="keyword">return</span> reloc.r_addend; &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">auto</span> get_addend_rel   = [&amp;]() -&gt; ElfW(Addr) &#123; <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;ElfW(Addr)*&gt;(rel_target); &#125;;</span><br><span class="line">  <span class="keyword">auto</span> get_addend_norel = [&amp;]() -&gt; ElfW(Addr) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 通常符号都不是STT_TLS类型</span></span><br><span class="line">  <span class="keyword">if</span> (IsGeneral &amp;&amp; is_tls_reloc(r_type)) &#123;</span><br><span class="line">    ... 省略</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里具体查找符号</span></span><br><span class="line">      <span class="keyword">if</span> (!lookup_symbol&lt;IsGeneral&gt;(relocator, r_sym, sym_name, &amp;found_in, &amp;sym)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (sym != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> should_protect_segments = handle_text_relocs &amp;&amp;</span><br><span class="line">                                             found_in == relocator.si &amp;&amp;</span><br><span class="line">                                             ELF_ST_TYPE(sym-&gt;st_info) == STT_GNU_IFUNC;</span><br><span class="line">        <span class="keyword">if</span> (should_protect_segments &amp;&amp; !protect_segments()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 计算符号地址ElfW(Sym) 加上模块基址</span></span><br><span class="line">        sym_addr = found_in-&gt;resolve_symbol_address(sym);</span><br><span class="line">        <span class="keyword">if</span> (should_protect_segments &amp;&amp; !unprotect_segments()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (IsGeneral) &#123;</span><br><span class="line">        <span class="comment">// A weak reference to an undefined symbol. We typically use a zero symbol address, but</span></span><br><span class="line">        <span class="comment">// use the relocation base for PC-relative relocations, so that the value written is zero.</span></span><br><span class="line">        <span class="keyword">switch</span> (r_type) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">          <span class="keyword">case</span> R_X86_64_PC32:</span><br><span class="line">            sym_addr = <span class="keyword">reinterpret_cast</span>&lt;ElfW(Addr)&gt;(rel_target);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)</span></span><br><span class="line">          <span class="keyword">case</span> R_386_PC32:</span><br><span class="line">            sym_addr = <span class="keyword">reinterpret_cast</span>&lt;ElfW(Addr)&gt;(rel_target);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 大部分符号类型都是 R_GENERIC_JUMP_SLOT </span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsGeneral || Mode == RelocMode::JumpTable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r_type == R_GENERIC_JUMP_SLOT) &#123;</span><br><span class="line">      count_relocation_if&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + get_addend_norel();</span><br><span class="line">      trace_reloc(<span class="string">&quot;RELO JMP_SLOT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">                  rel_target, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(result), sym_name);</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">      *<span class="keyword">static_cast</span>&lt;ElfW(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...省略其它类型符号地址计算及赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中最关键的符号查找调用<code>lookup_symbol</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> DoLogging&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="comment">// relocator 就是前面传进来包含全局组和本地组的soinfos，全局组排在最前面</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">lookup_symbol</span><span class="params">(Relocator&amp; relocator, <span class="keyword">uint32_t</span> r_sym, <span class="keyword">const</span> <span class="keyword">char</span>* sym_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 soinfo** found_in, <span class="keyword">const</span> ElfW(Sym)** sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (r_sym == relocator.cache_sym_val) &#123;</span><br><span class="line">    <span class="comment">// 如果是上次查询到的符号则没有必要再次查询</span></span><br><span class="line">    *found_in = relocator.cache_si;</span><br><span class="line">    *sym = relocator.cache_sym;</span><br><span class="line">    count_relocation_if&lt;DoLogging&gt;(kRelocSymbolCached);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断版本是否匹配</span></span><br><span class="line">    <span class="keyword">const</span> version_info* vi = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!relocator.si-&gt;lookup_version_info(relocator.version_tracker, r_sym, sym_name, &amp;vi)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    soinfo* local_found_in = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 最终调用soinfo_do_lookup查询符号</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* local_sym </span>= soinfo_do_lookup(sym_name, vi, &amp;local_found_in, relocator.lookup_list);</span><br><span class="line"></span><br><span class="line">    relocator.cache_sym_val = r_sym;</span><br><span class="line">    relocator.cache_si = local_found_in;</span><br><span class="line">    relocator.cache_sym = local_sym;</span><br><span class="line">    *found_in = local_found_in;</span><br><span class="line">    *sym = local_sym;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*sym == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ELF_ST_BIND(relocator.si_symtab[r_sym].st_info) != STB_WEAK) &#123;</span><br><span class="line">      DL_ERR(<span class="string">&quot;cannot locate symbol \&quot;%s\&quot; referenced by \&quot;%s\&quot;...&quot;</span>, sym_name, relocator.si-&gt;get_realpath());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count_relocation_if&lt;DoLogging&gt;(kRelocSymbol);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* <span class="title">soinfo_do_lookup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> version_info* vi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  soinfo** si_found_in, <span class="keyword">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lookup_list.needs_slow_path() ?</span><br><span class="line">      soinfo_do_lookup_impl&lt;<span class="literal">true</span>&gt;(name, vi, si_found_in, lookup_list) :</span><br><span class="line">      soinfo_do_lookup_impl&lt;<span class="literal">false</span>&gt;(name, vi, si_found_in, lookup_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> IsGeneral&gt;</span><br><span class="line">__attribute__((noinline)) <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>*</span></span><br><span class="line"><span class="function"><span class="comment">// 最终查找符号的实现函数</span></span></span><br><span class="line"><span class="function"><span class="title">soinfo_do_lookup_impl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> version_info* vi,</span></span></span><br><span class="line"><span class="function"><span class="params">                      soinfo** si_found_in, <span class="keyword">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> [ hash, name_len ] = calculate_gnu_hash(name);</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kBloomMaskBits = <span class="keyword">sizeof</span>(ElfW(Addr)) * <span class="number">8</span>;</span><br><span class="line">  <span class="function">SymbolName <span class="title">elf_symbol_name</span><span class="params">(name)</span></span>;</span><br><span class="line">  <span class="comment">// 这里的lookup_list正是调用 link_image传入的SymbolLookupLib，全局库在最前面</span></span><br><span class="line">  <span class="keyword">const</span> SymbolLookupLib* end = lookup_list.end();</span><br><span class="line">  <span class="keyword">const</span> SymbolLookupLib* it = lookup_list.begin();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> SymbolLookupLib* lib;</span><br><span class="line">    <span class="keyword">uint32_t</span> sym_idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over libraries until we find one whose Bloom filter matches the symbol we&#x27;re</span></span><br><span class="line">    <span class="comment">// searching for.</span></span><br><span class="line">    <span class="comment">// 每个库挨个查找有没有指定符号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (it == end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      lib = it++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IsGeneral &amp;&amp; lib-&gt;needs_sysv_lookup()) &#123;</span><br><span class="line">        <span class="comment">// 没有hash表则直接查找符号名</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> ElfW(Sym)* sym = lib-&gt;si_-&gt;find_symbol_by_name(elf_symbol_name, vi)) &#123;</span><br><span class="line">          *si_found_in = lib-&gt;si_;</span><br><span class="line">          <span class="keyword">return</span> sym;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IsGeneral) &#123;</span><br><span class="line">        TRACE_TYPE(LOOKUP, <span class="string">&quot;SEARCH %s in %s@%p (gnu)&quot;</span>,</span><br><span class="line">                   name, lib-&gt;si_-&gt;get_realpath(), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(lib-&gt;si_-&gt;base));</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 计算符号hash桶查询链</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> word_num = (hash / kBloomMaskBits) &amp; lib-&gt;gnu_maskwords_;</span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> bloom_word </span>= lib-&gt;gnu_bloom_filter_[word_num];</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> h1 = hash % kBloomMaskBits;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> h2 = (hash &gt;&gt; lib-&gt;gnu_shift2_) % kBloomMaskBits;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="number">1</span> &amp; (bloom_word &gt;&gt; h1) &amp; (bloom_word &gt;&gt; h2)) == <span class="number">1</span>) &#123;</span><br><span class="line">        sym_idx = lib-&gt;gnu_bucket_[hash % lib-&gt;gnu_nbucket_];</span><br><span class="line">        <span class="keyword">if</span> (sym_idx != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IsGeneral) &#123;</span><br><span class="line">        TRACE_TYPE(LOOKUP, <span class="string">&quot;NOT FOUND %s in %s@%p&quot;</span>,</span><br><span class="line">                   name, lib-&gt;si_-&gt;get_realpath(), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(lib-&gt;si_-&gt;base));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the library&#x27;s hash table chain.</span></span><br><span class="line">    ElfW(Versym) verneed = kVersymNotNeeded;</span><br><span class="line">    <span class="keyword">bool</span> calculated_verneed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> chain_value = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* sym </span>= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 根据符号hash快速查找</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      sym = lib-&gt;symtab_ + sym_idx;</span><br><span class="line">      chain_value = lib-&gt;gnu_chain_[sym_idx];</span><br><span class="line">      <span class="keyword">if</span> ((chain_value &gt;&gt; <span class="number">1</span>) == (hash &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vi != <span class="literal">nullptr</span> &amp;&amp; !calculated_verneed) &#123;</span><br><span class="line">          calculated_verneed = <span class="literal">true</span>;</span><br><span class="line">          verneed = find_verdef_version_index(lib-&gt;si_, vi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找必须版本匹配且符号被定义为全局</span></span><br><span class="line">        <span class="keyword">if</span> (check_symbol_version(lib-&gt;versym_, sym_idx, verneed) &amp;&amp;</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(sym-&gt;st_name) + name_len + <span class="number">1</span> &lt;= lib-&gt;strtab_size_ &amp;&amp;</span><br><span class="line">            <span class="built_in">memcmp</span>(lib-&gt;strtab_ + sym-&gt;st_name, name, name_len + <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            is_symbol_global_and_defined(lib-&gt;si_, sym)) &#123;</span><br><span class="line">          *si_found_in = lib-&gt;si_;</span><br><span class="line">          <span class="keyword">if</span> (IsGeneral) &#123;</span><br><span class="line">            TRACE_TYPE(LOOKUP, <span class="string">&quot;FOUND %s in %s (%p) %zd&quot;</span>,</span><br><span class="line">                       name, lib-&gt;si_-&gt;get_realpath(), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(sym-&gt;st_value),</span><br><span class="line">                       <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(sym-&gt;st_size));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> sym;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++sym_idx;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((chain_value &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsGeneral) &#123;</span><br><span class="line">      TRACE_TYPE(LOOKUP, <span class="string">&quot;NOT FOUND %s in %s@%p&quot;</span>,</span><br><span class="line">                 name, lib-&gt;si_-&gt;get_realpath(), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(lib-&gt;si_-&gt;base));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现最终实现符号查找在<code>soinfo_do_lookup_impl</code>查找规则是先查找全局库后查找依赖库，有hash表则查询hash表没用则直接查询符号名称，hash表也分为<code>elf hash</code>（低版本）与<code>gnu hash</code>（高版本）</p>
<p>因此我们已经知道了添加全局库的步骤如下</p>
<ol>
<li>将该全局库<code>soinfo</code>添加<code>DF_1_GLOBAL</code>标志<code>si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL)</code></li>
<li>添加该<code>soinfo</code>到所有链接命名空间<code>linked_ns-&gt;add_soinfo(si);si-&gt;add_secondary_namespace(linked_ns);</code></li>
</ol>
<p>分析源码也可知只有在<code>linker</code>初始化执行时才会有全局库的加载，后续使用<code>dlopen</code>并未解析，那么后续创建的命名空间也会包含全局库吗</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">android_namespace_t</span>* <span class="title">create_namespace</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* caller_addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">char</span>* ld_library_path,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">char</span>* default_library_path,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">uint64_t</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">char</span>* permitted_when_isolated_path,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">android_namespace_t</span>* parent_namespace)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建命名空间肯定会有一个父命名空间                                       </span></span><br><span class="line">  <span class="keyword">if</span> (parent_namespace == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// if parent_namespace is nullptr -&gt; set it to the caller namespace</span></span><br><span class="line">    soinfo* caller_soinfo = find_containing_library(caller_addr);</span><br><span class="line"></span><br><span class="line">    parent_namespace = caller_soinfo != <span class="literal">nullptr</span> ?</span><br><span class="line">                       caller_soinfo-&gt;get_primary_namespace() :</span><br><span class="line">                       g_anonymous_namespace;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ProtectedDataGuard guard;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ld_library_paths;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; default_library_paths;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; permitted_paths;</span><br><span class="line"></span><br><span class="line">  parse_path(ld_library_path, <span class="string">&quot;:&quot;</span>, &amp;ld_library_paths);</span><br><span class="line">  parse_path(default_library_path, <span class="string">&quot;:&quot;</span>, &amp;default_library_paths);</span><br><span class="line">  parse_path(permitted_when_isolated_path, <span class="string">&quot;:&quot;</span>, &amp;permitted_paths);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">android_namespace_t</span>* ns = <span class="keyword">new</span> (g_namespace_allocator.alloc()) <span class="keyword">android_namespace_t</span>();</span><br><span class="line">  ns-&gt;set_name(name);</span><br><span class="line">  ns-&gt;set_isolated((type &amp; ANDROID_NAMESPACE_TYPE_ISOLATED) != <span class="number">0</span>);</span><br><span class="line">  ns-&gt;set_greylist_enabled((type &amp; ANDROID_NAMESPACE_TYPE_GREYLIST_ENABLED) != <span class="number">0</span>);</span><br><span class="line">  ns-&gt;set_also_used_as_anonymous((type &amp; ANDROID_NAMESPACE_TYPE_ALSO_USED_AS_ANONYMOUS) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Android Java加载库会附带ANDROID_NAMESPACE_TYPE_SHARED标志</span></span><br><span class="line">  <span class="keyword">if</span> ((type &amp; ANDROID_NAMESPACE_TYPE_SHARED) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// append parent namespace paths.</span></span><br><span class="line">    <span class="comment">// 复制父命名空间的库加载路径，以及允许的路径</span></span><br><span class="line">    <span class="built_in">std</span>::copy(parent_namespace-&gt;get_ld_library_paths().begin(),</span><br><span class="line">              parent_namespace-&gt;get_ld_library_paths().end(),</span><br><span class="line">              back_inserter(ld_library_paths));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::copy(parent_namespace-&gt;get_default_library_paths().begin(),</span><br><span class="line">              parent_namespace-&gt;get_default_library_paths().end(),</span><br><span class="line">              back_inserter(default_library_paths));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::copy(parent_namespace-&gt;get_permitted_paths().begin(),</span><br><span class="line">              parent_namespace-&gt;get_permitted_paths().end(),</span><br><span class="line">              back_inserter(permitted_paths));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If shared - clone the parent namespace</span></span><br><span class="line">    <span class="comment">// Java调用完全继承所有soinfo</span></span><br><span class="line">    add_soinfos_to_namespace(parent_namespace-&gt;soinfo_list(), ns);</span><br><span class="line">    <span class="comment">// and copy parent namespace links</span></span><br><span class="line">    <span class="comment">// 同时继承链接命名空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; link : parent_namespace-&gt;linked_namespaces()) &#123;</span><br><span class="line">      ns-&gt;add_linked_namespace(link.linked_namespace(), link.shared_lib_sonames(),</span><br><span class="line">                               link.allow_all_shared_libs());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If not shared - copy only the shared group</span></span><br><span class="line">    <span class="comment">// 非Java调用只复制共享的库</span></span><br><span class="line">    add_soinfos_to_namespace(parent_namespace-&gt;get_shared_group(), ns);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ns-&gt;set_ld_library_paths(<span class="built_in">std</span>::move(ld_library_paths));</span><br><span class="line">  ns-&gt;set_default_library_paths(<span class="built_in">std</span>::move(default_library_paths));</span><br><span class="line">  ns-&gt;set_permitted_paths(<span class="built_in">std</span>::move(permitted_paths));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ns-&gt;is_also_used_as_anonymous() &amp;&amp; !set_anonymous_namespace(ns)) &#123;</span><br><span class="line">    DL_ERR(<span class="string">&quot;failed to set namespace: [name=\&quot;%s\&quot;, ld_library_path=\&quot;%s\&quot;, default_library_paths=\&quot;%s\&quot;&quot;</span></span><br><span class="line">           <span class="string">&quot; permitted_paths=\&quot;%s\&quot;] as the anonymous namespace&quot;</span>,</span><br><span class="line">           ns-&gt;get_name(),</span><br><span class="line">           android::base::Join(ns-&gt;get_ld_library_paths(), <span class="string">&#x27;:&#x27;</span>).c_str(),</span><br><span class="line">           android::base::Join(ns-&gt;get_default_library_paths(), <span class="string">&#x27;:&#x27;</span>).c_str(),</span><br><span class="line">           android::base::Join(ns-&gt;get_permitted_paths(), <span class="string">&#x27;:&#x27;</span>).c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">soinfo_list_t</span> <span class="title">android_namespace_t::get_shared_group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;g_default_namespace) &#123;</span><br><span class="line">    <span class="keyword">return</span> get_global_group();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">soinfo_list_t</span> shared_group;</span><br><span class="line">  soinfo_list().for_each([&amp;](soinfo* si) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((si-&gt;get_rtld_flags() &amp; RTLD_GLOBAL) != <span class="number">0</span>) &#123;</span><br><span class="line">      shared_group.push_back(si);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shared_group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里JAVA使用命名空间一般有两个，都是跟<code>ClassLoader</code>绑定在一起，包含系统<code>ClassLoader</code>和应用<code>ClassLoader</code>，关于命名空间介绍可以查看我的另一篇文章<a href="https://www.52pojie.cn/thread-948942-1-1.html">Android7.0以上命名空间详解(dlopen限制)</a>，<code>get_shared_group</code>查找了命名空间内<code>soinfo</code>的<code>RTLD_GLOBAL</code>库查找，所以只要我们将全局库添加至所有命名空间并设置好标志后续创建的库都会默认包含我们的库。</p>
<p>分析到这里我们的目的已经很明确了：1.设置全局标志。2.将库添加到所有命名空间。当然Android7.0以下没有命名空间则直接省略第二步。</p>
<h2 id="代码实现添加全局库-参考fake-linker源码"><a href="#代码实现添加全局库-参考fake-linker源码" class="headerlink" title="代码实现添加全局库  参考fake-linker源码"></a>代码实现添加全局库  参考<a href="https://github.com/sanfengAndroid/fake-linker">fake-linker</a>源码</h2><ol>
<li><p>获取所有命名空间</p>
<p> 在<code>linker_main.cpp</code>中有<code>static soinfo* solist;</code>全局静态变量，通过它可以获取到所有已加载的<code>soinfo</code>进而得到所有命名空间，执行时机越早则找到的命名空间越全，可能存在部分Android使用的命名空间无法找到，只需要在Hook模块特殊处理<code>android_dlopen_ext</code>确保添加全局库即可</p>
</li>
<li><p>设置全局库</p>
<p> 参考项目<a href="https://github.com/sanfengAndroid/fake-linker">fake-linker</a>源码</p>
</li>
<li><p>项目其它的一些处理</p>
<ol>
<li>每个Android版本<code>soinfo</code>几乎都有变动，且不同版本使用STL版本可能还不一样，因此针对每个API等级一个库，目前支持Android 5.0~Android 11</li>
<li>源码涉及到一些<code>linker</code>内部符号查找，通过解析节区符号表来实现，通常来说<code>linker</code>都没有去除内部符号表，但是其它模块几乎都是去除掉的，因此对于某些特别手机<code>linker</code>去除掉内部符号表则无法使用</li>
<li>由于执行时机的问题某些模块（”libjavacore.so”, “libnativehelper.so”, “libnativeloader.so”, “libart.so”, “libopenjdk.so”，我们在Application执行其系统环境已经准备好了）已经链接过了，这时需要调用提供的接口重新链接符号</li>
<li>模块内部处理了<code>dlopen,dlsym</code>等函数，Hook模块可以拦截这些函数，然后调用提供的接口就可以恢复环境</li>
<li>内部提供手动重链接和系统重链接，手动重链接自己实现解析符号因此可以设置过滤项</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过设置<code>LD_PRELOAD</code>环境变量一是执行时机问题，二是权限问题，三是某些符号无法拦截等缺陷，而我们手动更改设置全局库则不受这些影响，甚至可以控制指定模块，指定符号的Hook，只是内部解析符号和适配Android版本稍微麻烦一点。</p>
<p>上面代码分析可能有些乱，但是你只需要记住Android7.0以下全局库只需要设置<code>soinfo</code>的全局标志即可，Android7.0以上命名空间限制则还要要将全局库<code>soinfo</code>添加到所有命名空间即可，后续创建的命名空间必然继承全局库，然后因为执行时机问题一些库已经加载并链接了，因此我们要重新链接它的导入符号。</p>
]]></content>
      <categories>
        <category>Android Hook</category>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android Hook</tag>
        <tag>PLT Hook</tag>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/blog/2022/01/11/test/</url>
    <content><![CDATA[<blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote>

<p>TTTTT</p>
]]></content>
  </entry>
  <entry>
    <title>一种通用超简单的Android Java Native方法Hook</title>
    <url>/blog/2021/02/28/simple-java-native-hook/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前 <code>Android</code> 上 <code>Hook</code> 的框架已经很多了，但是支持 <code>Java Native</code> 方法的 <code>Hook</code> 却很少，这些框架将 <code>native</code> 方法当普通方法 <code>Hook</code>，适配不同架构复杂等等。本文介绍一种 <code>Android</code> 版本通用的 <code>Java Native Hook</code> 方法并实现代码很少，下面进入我们的分析。</p>
<a id="more"></a>
<h2 id="native-方法注册"><a href="#native-方法注册" class="headerlink" title="native 方法注册"></a>native 方法注册</h2><p>目前 <code>native</code> 方法只有两种方式</p>
<ul>
<li>一种是采用导出符号 类名+方法名，然后调用时采用的动态查找方式，其格式如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_sanfengandroid_fakelinker_FakeLinker_setLogLevel</span><span class="params">(JNIEnv *env, jclass clazz, jint level)</span> </span>&#123;</span><br><span class="line">    g_log_level = level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>另一种方式采用动态注册调用 <code>JNI</code> 函数 <code>RegisterNatives</code> 动态注册函数</li>
</ul>
<h2 id="native-方法-Hook-思路"><a href="#native-方法-Hook-思路" class="headerlink" title="native 方法 Hook 思路"></a>native 方法 Hook 思路</h2><p>根据上面两种方式很自然想到了两种 <code>Hook</code> 方法</p>
<ol>
<li>自己实现另一个方法并且同样导出该方法的签名，但是需要保证动态查找时要优先查找你自己函数，且高版本还有命名空间限制</li>
<li>既然调用 <code>RegisterNatives</code> 就能注册函数，那假如我们再次调用是不是覆盖掉之前的呢，答案是可以，本文正是通过再次调用 <code>RegisterNatives</code> 重新注册函数从而达到 <code>Hook</code> 的效果，下面进入具体分析。</li>
</ol>
<h2 id="RegisterNatives-源码分析"><a href="#RegisterNatives-源码分析" class="headerlink" title="RegisterNatives 源码分析"></a>RegisterNatives 源码分析</h2><p><code>RegisterNatives</code> 最新源码实现位置在 <a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/jni/jni_internal.cc;l=2310?q=jni_internal.cc&ss=android/platform/superproject">art/runtime/jni/jni_internal.cc</a>，其源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">RegisterNatives</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                            jclass java_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> JNINativeMethod* methods,</span></span></span><br><span class="line"><span class="function"><span class="params">                            jint method_count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(method_count &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    JavaVmExtFromEnv(env)-&gt;JniAbortF(<span class="string">&quot;RegisterNatives&quot;</span>, <span class="string">&quot;negative method count: %d&quot;</span>,</span><br><span class="line">                                    method_count);</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;  <span class="comment">// Not reached except in unit tests.</span></span><br><span class="line">  &#125;</span><br><span class="line">  CHECK_NON_NULL_ARGUMENT_FN_NAME(<span class="string">&quot;RegisterNatives&quot;</span>, java_class, JNI_ERR);</span><br><span class="line">  ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">  <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(soa.Self())</span></span>;</span><br><span class="line">  Handle&lt;mirror::Class&gt; c = hs.NewHandle(soa.Decode&lt;mirror::Class&gt;(java_class));</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(method_count == <span class="number">0</span>)) &#123;</span><br><span class="line">    LOG(WARNING) &lt;&lt; <span class="string">&quot;JNI RegisterNativeMethods: attempt to register 0 native methods for &quot;</span></span><br><span class="line">        &lt;&lt; c-&gt;PrettyDescriptor();</span><br><span class="line">    <span class="keyword">return</span> JNI_OK;</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK_NON_NULL_ARGUMENT_FN_NAME(<span class="string">&quot;RegisterNatives&quot;</span>, methods, JNI_ERR);</span><br><span class="line">  <span class="keyword">for</span> (jint i = <span class="number">0</span>; i &lt; method_count; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = methods[i].name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* sig = methods[i].signature;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* fnPtr = methods[i].fnPtr;</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(name == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;method name&quot;</span>, i);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(sig == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;method signature&quot;</span>, i);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(fnPtr == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      ReportInvalidJNINativeMethod(soa, c.Get(), <span class="string">&quot;native function&quot;</span>, i);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> is_fast = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*sig == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">      is_fast = <span class="literal">true</span>;</span><br><span class="line">      ++sig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面是一些参数验证</span></span><br><span class="line">    ArtMethod* m = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">bool</span> warn_on_going_to_parent = down_cast&lt;JNIEnvExt*&gt;(env)-&gt;GetVm()-&gt;IsCheckJniEnabled();</span><br><span class="line">    <span class="keyword">for</span> (ObjPtr&lt;mirror::Class&gt; current_class = c.Get();</span><br><span class="line">        current_class != <span class="literal">nullptr</span>;</span><br><span class="line">        current_class = current_class-&gt;GetSuperClass()) &#123;</span><br><span class="line">      <span class="comment">// 查询方法对应的 ArtMethod 对象</span></span><br><span class="line">      m = FindMethod&lt;<span class="literal">true</span>&gt;(current_class, name, sig);</span><br><span class="line">      <span class="keyword">if</span> (m != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Search again comparing to all methods, to find non-native methods that match.</span></span><br><span class="line">      m = FindMethod&lt;<span class="literal">false</span>&gt;(current_class, name, sig);</span><br><span class="line">      <span class="keyword">if</span> (m != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (warn_on_going_to_parent) &#123;</span><br><span class="line">        LOG(WARNING) &lt;&lt; <span class="string">&quot;CheckJNI: method to register \&quot;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\&quot; not in the given class. &quot;</span></span><br><span class="line">                    &lt;&lt; <span class="string">&quot;This is slow, consider changing your RegisterNatives calls.&quot;</span>;</span><br><span class="line">        warn_on_going_to_parent = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      c-&gt;DumpClass(LOG_STREAM(ERROR), mirror::Class::kDumpClassFullDetail);</span><br><span class="line">      LOG(ERROR)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Failed to register native method &quot;</span></span><br><span class="line">          &lt;&lt; c-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; name &lt;&lt; sig &lt;&lt; <span class="string">&quot; in &quot;</span></span><br><span class="line">          &lt;&lt; c-&gt;GetDexCache()-&gt;GetLocation()-&gt;ToModifiedUtf8();</span><br><span class="line">      ThrowNoSuchMethodError(soa, c.Get(), name, sig, <span class="string">&quot;static or non-static&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!m-&gt;IsNative()) &#123;</span><br><span class="line">      <span class="comment">// 非 native 方法是不能注册的</span></span><br><span class="line">      LOG(ERROR)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Failed to register non-native method &quot;</span></span><br><span class="line">          &lt;&lt; c-&gt;PrettyDescriptor() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; name &lt;&lt; sig</span><br><span class="line">          &lt;&lt; <span class="string">&quot; as native&quot;</span>;</span><br><span class="line">      ThrowNoSuchMethodError(soa, c.Get(), name, sig, <span class="string">&quot;native&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VLOG(jni) &lt;&lt; <span class="string">&quot;[Registering JNI native method &quot;</span> &lt;&lt; m-&gt;PrettyMethod() &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(is_fast)) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; <span class="string">&quot;!bang JNI is deprecated. Switch to @FastNative for &quot;</span> &lt;&lt; m-&gt;PrettyMethod();</span><br><span class="line">      is_fast = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> make this a hard register error in the future.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终调用 class_linker-&gt;RegisterNative 来实际进行注册</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* final_function_ptr = class_linker-&gt;RegisterNative(soa.Self(), m, fnPtr);</span><br><span class="line">    UNUSED(final_function_ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> JNI_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要进行各种验证并查找方法对应的 <code>ArtMethod</code>，其中 <code>FastNative</code> 在 Android8.0 以后已经采用注解的方式了，最终调用 <code>class_linker-&gt;RegisterNative(soa.Self(), m, fnPtr)</code> 来完成函数注册，接着分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">ClassLinker::RegisterNative</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Thread* self, ArtMethod* method, <span class="keyword">const</span> <span class="keyword">void</span>* native_method)</span> </span>&#123;</span><br><span class="line">  CHECK(method-&gt;IsNative()) &lt;&lt; method-&gt;PrettyMethod();</span><br><span class="line">  CHECK(native_method != <span class="literal">nullptr</span>) &lt;&lt; method-&gt;PrettyMethod();</span><br><span class="line">  <span class="keyword">void</span>* new_native_method = <span class="literal">nullptr</span>;</span><br><span class="line">  Runtime* runtime = Runtime::Current();</span><br><span class="line">  <span class="comment">// 这里 JVMTI 响应注册事件</span></span><br><span class="line">  runtime-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(method,</span><br><span class="line">                                                       native_method,</span><br><span class="line">                                                       <span class="comment">/*out*/</span>&amp;new_native_method);</span><br><span class="line">  <span class="keyword">if</span> (method-&gt;IsCriticalNative()) &#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">lock</span><span class="params">(self, critical_native_code_with_clinit_check_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// Remove old registered method if any.</span></span><br><span class="line">    <span class="keyword">auto</span> it = critical_native_code_with_clinit_check_.find(method);</span><br><span class="line">    <span class="keyword">if</span> (it != critical_native_code_with_clinit_check_.end()) &#123;</span><br><span class="line">      critical_native_code_with_clinit_check_.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To ensure correct memory visibility, we need the class to be visibly</span></span><br><span class="line">    <span class="comment">// initialized before we can set the JNI entrypoint.</span></span><br><span class="line">    <span class="keyword">if</span> (method-&gt;GetDeclaringClass()-&gt;IsVisiblyInitialized()) &#123;</span><br><span class="line">      method-&gt;SetEntryPointFromJni(new_native_method);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      critical_native_code_with_clinit_check_.emplace(method, new_native_method);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    method-&gt;SetEntryPointFromJni(new_native_method);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> new_native_method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关 <code>JVMTI</code> 大家可以网上搜索，通过它能做到很多黑科技并且这里也使用了它修改后的 <code>new_native_method</code>，因此通过 <code>JVMTI</code> 也能达到 <code>Hook</code>。 ，这里判断 <code>CriticalNative</code> 如果没有初始化类则先要初始化类，然后再注册。最终实现注册的是 <code>method-&gt;SetEntryPointFromJni(new_native_method)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetEntryPointFromJni</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* entrypoint)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The resolution method also has a JNI entrypoint for direct calls from</span></span><br><span class="line">  <span class="comment">// compiled code to the JNI dlsym lookup stub for @CriticalNative.</span></span><br><span class="line">  DCHECK(IsNative() || IsRuntimeMethod());</span><br><span class="line">  SetEntryPointFromJniPtrSize(entrypoint, kRuntimePointerSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终只是设置 <code>ArtMethod</code> 对象中的 <code>jni</code> 入口点指针为我们的注册函数，上面是主分支代码分析，<code>Android 11</code> 及以下都是调用的 <code>ArtMethod::RegisterNative</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android 9 ~ 11</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">ArtMethod::RegisterNative</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* native_method)</span> </span>&#123;</span><br><span class="line">  CHECK(IsNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  CHECK(native_method != <span class="literal">nullptr</span>) &lt;&lt; PrettyMethod();</span><br><span class="line">  <span class="keyword">void</span>* new_native_method = <span class="literal">nullptr</span>;</span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(<span class="keyword">this</span>,</span><br><span class="line">                                                                  native_method,</span><br><span class="line">                                                                  <span class="comment">/*out*/</span>&amp;new_native_method);</span><br><span class="line">  SetEntryPointFromJni(new_native_method);</span><br><span class="line">  <span class="keyword">return</span> new_native_method;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Android 9 以下</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">ArtMethod::RegisterNative</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* native_method, <span class="keyword">bool</span> is_fast)</span> </span>&#123;</span><br><span class="line">  CHECK(IsNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  <span class="comment">// 多了一个 FastNative 检测,在已经注册为 FastNative 后不能再次注册</span></span><br><span class="line">  CHECK(!IsFastNative()) &lt;&lt; PrettyMethod();</span><br><span class="line">  CHECK(native_method != <span class="literal">nullptr</span>) &lt;&lt; PrettyMethod();</span><br><span class="line">  <span class="keyword">if</span> (is_fast) &#123;</span><br><span class="line">    AddAccessFlags(kAccFastNative);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span>* new_native_method = <span class="literal">nullptr</span>;</span><br><span class="line">  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(<span class="keyword">this</span>,</span><br><span class="line">                                                                  native_method,</span><br><span class="line">                                                                  <span class="comment">/*out*/</span>&amp;new_native_method);</span><br><span class="line">  SetEntryPointFromJni(new_native_method);</span><br><span class="line">  <span class="keyword">return</span> new_native_method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到在 <code>Android 9</code> 以上直接调用即可覆盖掉，<code>Android 9</code> 以下需要清理 <code>FastNative</code> 标志</p>
<h2 id="Java-Native-代码实现"><a href="#Java-Native-代码实现" class="headerlink" title="Java Native 代码实现"></a>Java Native 代码实现</h2><ul>
<li><p>所有代码都可以在我的 <a href="https://github.com/sanfengAndroid/fake-linker/blob/main/src/main/cpp/linker/art/hook_jni_native_interface_impl.cpp">fake-linker</a> 中找到</p>
</li>
<li><p>经过上面分析要 <code>Hook</code> 则只需要调用 <code>RegisterNatives</code> 方法，而我们还要备份原方法方便后面可以调用，而原方法的地址在 <code>ArtMethod</code> 对象中的 <code>jni</code> 入口指针中保存，因此需要查找 <code>ArtMethod</code>，为了简单适配不同我们自己手动注册一个函数，然后再拿这个地址跟 <code>ArtMethod</code> 对象中去比较获取偏移量</p>
<ol>
<li>获取方法的 <code>ArtMethod</code> 指针，在 <code>Android 11</code> 以下 <code>jmethodID</code> 就是实际的 <code>ArtMethod</code> 指针，<code>Android 11</code> 以上不返回真实的 <code>ArtMethod</code> 指针，但在 Java Method 对象中有一个 <code>private long artMethod</code> 保存着 <code>ArtMethod</code> 指针，其它 <code>Hook</code> 框架都有介绍就不分析了，因此获取 <code>ArtMethod</code> 指针如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">GetArtMethod</span><span class="params">(JNIEnv *env, jclass clazz, jmethodID methodId)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __ANDROID_API__ &gt;= __ANDROID_API_R__</span></span><br><span class="line">    <span class="keyword">if</span> (IsIndexId(methodId))&#123;</span><br><span class="line">        jobject method = env-&gt;ToReflectedMethod(clazz, methodId, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(env-&gt;GetLongField(method, field_art_method));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> methodId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查找 <code>jni</code> 入口指针偏移，指针对齐<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> *artMethod = <span class="keyword">static_cast</span>&lt;<span class="keyword">uintptr_t</span> *&gt;(GetArtMethod(env, clazz, methodId));</span><br><span class="line"><span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 直接与我们自己注册的 native 方法地址相比较</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(artMethod[i]) == native) &#123;</span><br><span class="line">        jni_offset = i;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">        LOGD(<span class="string">&quot;found art method entrypoint jni offset: %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>读取方法原注册地址<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">GetOriginalNativeFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uintptr_t</span> *art_method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__predict_false(art_method == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) art_method[jni_offset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>在 <code>Android 9</code> 以下如果原方法是 <code>FastNative</code> 类型则还需要清除标志，因此还要查找 <code>uint32_t accessFlags</code> 成员的偏移，这里我们又采用查找的方式，来确定偏移，使用 <code>uint32_t</code> 对齐，我这里选择的是 <code>0x109</code> 标志也就是 <code>public static native</code>，这里最好要有 <code>public</code> 标志 <code>0x1</code>，因为正常指针都是 4/8 字节对齐的，这样避免误判</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (api &gt;= __ANDROID_API_Q__)&#123;</span><br><span class="line">    <span class="comment">// 非内部隐藏类</span></span><br><span class="line">    flags |= <span class="number">0x10000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *start = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(artMethod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">18</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> value = *(<span class="keyword">uint32_t</span> *) (start + i * <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (value == flags) &#123;</span><br><span class="line">        access_flags_art_method_offset = i * <span class="number">4</span>;</span><br><span class="line">        LOGD(<span class="string">&quot;found art method match access flags offset: %d&quot;</span>, i * <span class="number">4</span>);</span><br><span class="line">        success &amp;= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (access_flags_art_method_offset &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (api &gt;= __ANDROID_API_N__) &#123;</span><br><span class="line">        access_flags_art_method_offset = <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (api == __ANDROID_API_M__)&#123;</span><br><span class="line">        access_flags_art_method_offset = <span class="number">12</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (api == __ANDROID_API_L_MR1__)&#123;</span><br><span class="line">        access_flags_art_method_offset = <span class="number">20</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (api == __ANDROID_API_L__)&#123;</span><br><span class="line">        access_flags_art_method_offset = <span class="number">56</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>准备工作完成了就该实现具体的 <code>Hook</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RegisterNativeAgain</span><span class="params">(JNIEnv *env, jclass clazz, HookRegisterNativeUnit *items, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (clazz == <span class="literal">nullptr</span> || items == <span class="literal">nullptr</span> || len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      LOGE(<span class="string">&quot;Registration class or method cannot be empty&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line">  JNINativeMethod methods[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      JNINativeMethod hook = items[i].hook_method;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *sign = hook.signature;</span><br><span class="line">      <span class="keyword">if</span> (sign[<span class="number">0</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">          sign++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第一步：查找方法的 jmethodID，这里要去除 FastNative标志的签名，否者查找不成功</span></span><br><span class="line">      jmethodID methodId = items[i].is_static ? env-&gt;GetStaticMethodID(clazz, hook.name, sign) : env-&gt;GetMethodID(clazz, hook.name, sign);</span><br><span class="line">      <span class="keyword">if</span> (methodId == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          LOGE(<span class="string">&quot;Find method failed, name: %s, signature: %s, is static: %d&quot;</span>, hook.name, hook.signature, items[i].is_static);</span><br><span class="line">          JNIHelper::PrintAndClearException(env);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第二步：获取方法对应的 ArtMethod 指针</span></span><br><span class="line">      <span class="keyword">void</span> *artMethod = GetArtMethod(env, clazz, methodId);</span><br><span class="line">      <span class="comment">// 第三步：备份原方法</span></span><br><span class="line">      <span class="keyword">void</span> *backup = GetOriginalNativeFunction(<span class="keyword">static_cast</span>&lt;<span class="keyword">uintptr_t</span> *&gt;(artMethod));</span><br><span class="line">      <span class="keyword">if</span> (backup == hook.fnPtr) &#123;</span><br><span class="line">          LOGE(<span class="string">&quot;The same native method has been registered, name: %s, signature: %s, address: %p, is static: %d&quot;</span>,</span><br><span class="line">              hook.name, hook.signature, hook.fnPtr, items[i].is_static);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (items[i].backup_method != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          *(items[i].backup_method) = backup;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!HasAccessFlag(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(artMethod), kAccNative)) &#123;</span><br><span class="line">          LOGE(<span class="string">&quot;You are hooking a non-native method, name: %s, signature: %s, is static: %d&quot;</span>, hook.name, hook.signature, items[i].is_static);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 第四步：Android 9 以下如果有 FastNative 标志则还需要清除</span></span><br><span class="line">      <span class="keyword">bool</span> restore = ClearFastNativeFlag(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(artMethod));</span><br><span class="line">      <span class="keyword">if</span> (api &gt;= __ANDROID_API_O__) &#123;</span><br><span class="line">          hook.signature = sign;</span><br><span class="line">      &#125;</span><br><span class="line">      methods[<span class="number">0</span>] = hook;</span><br><span class="line">      <span class="comment">// 第五步：重新注册为我们的 Hook 方法</span></span><br><span class="line">      <span class="keyword">if</span> (env-&gt;RegisterNatives(clazz, methods, <span class="number">1</span>) == JNI_OK) &#123;</span><br><span class="line">          success++;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Android 8.0 ,8.1 必须清除 FastNative 标志才能注册成功,所以如果原来包含 FastNative 标志还得恢复,</span></span><br><span class="line"><span class="comment">          * 否者调用原方法可能会出现问题</span></span><br><span class="line"><span class="comment">          * */</span></span><br><span class="line">          <span class="comment">// 第六步：如果需要则恢复原函数的 FastNative 标志</span></span><br><span class="line">          <span class="keyword">if</span> (restore &amp;&amp; (api == __ANDROID_API_O__ || api == __ANDROID_API_O_MR1__)) &#123;</span><br><span class="line">              AddAccessFlag(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(artMethod), kAccFastNative);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          LOGE(<span class="string">&quot;register native function failed, method name: %s, sign: %s, is static: %d&quot;</span>, hook.name, hook.signature, items[i].is_static);</span><br><span class="line">          JNIHelper::PrintAndClearException(env);</span><br><span class="line">          <span class="keyword">if</span> (restore) &#123;</span><br><span class="line">              AddAccessFlag(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(artMethod), kAccFastNative);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (items[i].backup_method != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">              *(items[i].backup_method) = <span class="literal">nullptr</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2></li>
<li><p>参考我的 <a href="https://github.com/sanfengAndroid/FakeXposed/blob/main/app/src/main/cpp/hook/hook_java_native.cpp">数据滤镜</a> 内部完成了 <code>VMDebug.isDebuggerConnected</code>，<code>Throwable.nativeGetStackTrace</code>，<code>Class.classForName</code> 等等函数</p>
</li>
<li><p>上面我们采用重新注册来替换原来的地址，那么自然第一种动态查找的 <code>native</code> 方法我们也采取动态注册的方法占坑，然后系统就不会再走查找流程，如果我们要调用原函数则自己动态查找符号即可</p>
</li>
<li><p>上面的方式需要在原方法已经注册后再 Hook，不然拿到的地址只是动态查找入口地址，那么假如我们不知道它什么时候注册该怎么办呢，或者我们先注册后面又被它自己重新注册呢。 这种情况我们可以 <code>Hook</code> <code>RegisterNative</code> 函数，其具体实现也在我的 <a href="https://github.com/sanfengAndroid/fake-linker/blob/main/src/main/cpp/linker/art/hook_jni_native_interface_impl.cpp">fake-linker</a> 中，<code>Hook JNI</code> 函数更加简单，本质上只是一些函数指针，直接替换为我们的即可，但是要注意读写权限</p>
</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>在 <code>Android 9</code> 以上不能反射隐藏类，通过 <code>jni</code> 函数也不能获取到，因此需要先过掉反射限制</li>
<li><code>Android 8</code> 以下使用的是 <code>!bang JNI</code>，8 及以上使用 <code>FastNative</code>，参考 <a href="https://source.android.google.cn/devices/tech/dalvik/improvements?hl=zh-cn">变更</a>，因此低版本注册 <code>FastNative</code> 方法时签名需要 <code>!</code> 开头</li>
<li>在源码中注册都是加了锁的而我们没有加锁，因此理论上可能会出错，但实际上 <code>ArtMethod</code> 位置并不会改变，并且注册以后通常其值也不会改变，因此没有必要加锁</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>通过上面的方法调用 <code>RegisterNatives</code> 来交给系统帮我们 <code>Hook</code> 这样减少很大的适配，而我们只需获取原方法地址和访问标志适配代码量大大减少且通用性更强。在 <code>Android</code> 中比较关键的函数基本都是在 <code>Native</code> 方法中完成，因此适用性还是挺高的。</li>
<li>避免被检测性加强，因为我们 <code>Hook</code> 更底层的 <code>Native</code> 函数，整个过程唯一变动的就是 <code>ArtMethod</code> 中的 <code>jni</code> 入口指针，这样检测难度稍微增加</li>
<li>不必依赖任何框架，更加减少更检测到的可能性</li>
<li>缺点就是 <code>Java Hook</code> 变成了 <code>native hook</code> 了，编写代码的难度上升了一些，当然你可以注册一个通用的 <code>native</code> 函数做跳板，然后跳转回 <code>Java</code> 处理</li>
</ul>
<h2 id="我的项目参考"><a href="#我的项目参考" class="headerlink" title="我的项目参考"></a>我的项目参考</h2><p><a href="https://github.com/sanfengAndroid/fake-linker">fake-linker</a> 集成 <code>JNI</code>，<code>Java native</code> 函数 <code>Hook</code>，<code>LD_PRELOAD</code> 模式的 <code>PLT Hook</code>，<code>Android 7</code>以上绕过命名空间限制等等</p>
<p><a href="https://github.com/sanfengAndroid/FakeXposed">数据滤镜</a> 用于分析恶意软件，提供高度自由的数据过滤，文件重定向，maps 文件过滤，动态符号查找过滤等等</p>
<h1 id="原文我的博客链接点击-这里"><a href="#原文我的博客链接点击-这里" class="headerlink" title="原文我的博客链接点击 这里"></a>原文我的博客链接点击 <a href="https://sanfengandroid.github.io/2021/02/28/simple-java-native-hook/">这里</a></h1>]]></content>
      <categories>
        <category>Android Hook</category>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android Hook</tag>
        <tag>Android源码</tag>
      </tags>
  </entry>
</search>
